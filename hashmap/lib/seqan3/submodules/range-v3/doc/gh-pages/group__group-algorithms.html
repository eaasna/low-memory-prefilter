<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Range-v3: Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Range-v3
   </div>
   <div id="projectbrief">Range algorithms, views, and actions for the Standard Library</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group-algorithms.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Algorithms</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Iterator- and range-based algorithms, like the standard algorithms. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4ec55cd1aee7604d0c5a335fb3d8641b"><td class="memTemplParams" colspan="2"><a id="ga4ec55cd1aee7604d0c5a335fb3d8641b"></a>
template&lt;typename I1 , typename I2 , typename O &gt; </td></tr>
<tr class="memitem:ga4ec55cd1aee7604d0c5a335fb3d8641b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::binary_transform_result</b> = detail::in1_in2_out_result&lt; I1, I2, O &gt;</td></tr>
<tr class="separator:ga4ec55cd1aee7604d0c5a335fb3d8641b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e197a7893ec8659fb7e2513130f7cf"><td class="memTemplParams" colspan="2"><a id="ga58e197a7893ec8659fb7e2513130f7cf"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga58e197a7893ec8659fb7e2513130f7cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_backward_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga58e197a7893ec8659fb7e2513130f7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a179c5b7b8620b7fd95dc315cab0a39"><td class="memTemplParams" colspan="2"><a id="ga5a179c5b7b8620b7fd95dc315cab0a39"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga5a179c5b7b8620b7fd95dc315cab0a39"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_if_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga5a179c5b7b8620b7fd95dc315cab0a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ac60776de9431e79a65c4897bd2e3d"><td class="memTemplParams" colspan="2"><a id="gae2ac60776de9431e79a65c4897bd2e3d"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gae2ac60776de9431e79a65c4897bd2e3d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_n_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gae2ac60776de9431e79a65c4897bd2e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab309c6678ed7ad0eea22415f3d66514a"><td class="memTemplParams" colspan="2"><a id="gab309c6678ed7ad0eea22415f3d66514a"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gab309c6678ed7ad0eea22415f3d66514a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gab309c6678ed7ad0eea22415f3d66514a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84025d197692778e238c2143ee2dcdee"><td class="memTemplParams" colspan="2"><a id="ga84025d197692778e238c2143ee2dcdee"></a>
template&lt;typename I , typename F &gt; </td></tr>
<tr class="memitem:ga84025d197692778e238c2143ee2dcdee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::for_each_result</b> = detail::in_fun_result&lt; I, F &gt;</td></tr>
<tr class="separator:ga84025d197692778e238c2143ee2dcdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cd85c482465e0fef02aec6733ec5e8a"><td class="memTemplParams" colspan="2"><a id="ga0cd85c482465e0fef02aec6733ec5e8a"></a>
template&lt;typename O , typename F &gt; </td></tr>
<tr class="memitem:ga0cd85c482465e0fef02aec6733ec5e8a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::generate_n_result</b> = detail::out_fun_result&lt; O, F &gt;</td></tr>
<tr class="separator:ga0cd85c482465e0fef02aec6733ec5e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b78921a0e76ce435f8c180041296192"><td class="memTemplParams" colspan="2"><a id="ga4b78921a0e76ce435f8c180041296192"></a>
template&lt;typename O , typename F &gt; </td></tr>
<tr class="memitem:ga4b78921a0e76ce435f8c180041296192"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::generate_result</b> = detail::out_fun_result&lt; O, F &gt;</td></tr>
<tr class="separator:ga4b78921a0e76ce435f8c180041296192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb3de5f6f61105bed9816cbbe1c20e4"><td class="memTemplParams" colspan="2"><a id="ga4fb3de5f6f61105bed9816cbbe1c20e4"></a>
template&lt;typename I0 , typename I1 , typename O &gt; </td></tr>
<tr class="memitem:ga4fb3de5f6f61105bed9816cbbe1c20e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::merge_result</b> = detail::in1_in2_out_result&lt; I0, I1, O &gt;</td></tr>
<tr class="separator:ga4fb3de5f6f61105bed9816cbbe1c20e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2551631b044f18c25ebf252d89ab62d1"><td class="memTemplParams" colspan="2"><a id="ga2551631b044f18c25ebf252d89ab62d1"></a>
template&lt;typename I &gt; </td></tr>
<tr class="memitem:ga2551631b044f18c25ebf252d89ab62d1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::minmax_element_result</b> = detail::min_max_result&lt; I, I &gt;</td></tr>
<tr class="separator:ga2551631b044f18c25ebf252d89ab62d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33d3732bfda9763bacb492f678c49ac2"><td class="memTemplParams" colspan="2"><a id="ga33d3732bfda9763bacb492f678c49ac2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga33d3732bfda9763bacb492f678c49ac2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::minmax_result</b> = detail::min_max_result&lt; T, T &gt;</td></tr>
<tr class="separator:ga33d3732bfda9763bacb492f678c49ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga228c0cdeb71847092b416b855e17c017"><td class="memTemplParams" colspan="2"><a id="ga228c0cdeb71847092b416b855e17c017"></a>
template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:ga228c0cdeb71847092b416b855e17c017"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::mismatch_result</b> = detail::in1_in2_result&lt; I1, I2 &gt;</td></tr>
<tr class="separator:ga228c0cdeb71847092b416b855e17c017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ddbe128fcdd14998784890ae88172c"><td class="memTemplParams" colspan="2"><a id="gaf3ddbe128fcdd14998784890ae88172c"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaf3ddbe128fcdd14998784890ae88172c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::move_backward_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaf3ddbe128fcdd14998784890ae88172c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e56e40c245536a73cd3c4479aa71f0"><td class="memTemplParams" colspan="2"><a id="gaa9e56e40c245536a73cd3c4479aa71f0"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaa9e56e40c245536a73cd3c4479aa71f0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::move_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaa9e56e40c245536a73cd3c4479aa71f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga196586ea2693c3b679d7c75c8c8c4eb2"><td class="memTemplParams" colspan="2"><a id="ga196586ea2693c3b679d7c75c8c8c4eb2"></a>
template&lt;typename I , typename O0 , typename O1 &gt; </td></tr>
<tr class="memitem:ga196586ea2693c3b679d7c75c8c8c4eb2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::partition_copy_result</b> = detail::in_out1_out2_result&lt; I, O0, O1 &gt;</td></tr>
<tr class="separator:ga196586ea2693c3b679d7c75c8c8c4eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81824d68277efdaa55addad2b5a1ab09"><td class="memTemplParams" colspan="2"><a id="ga81824d68277efdaa55addad2b5a1ab09"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga81824d68277efdaa55addad2b5a1ab09"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove_copy_if_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga81824d68277efdaa55addad2b5a1ab09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbea707ae03721b200a22fe6918920d8"><td class="memTemplParams" colspan="2"><a id="gacbea707ae03721b200a22fe6918920d8"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gacbea707ae03721b200a22fe6918920d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gacbea707ae03721b200a22fe6918920d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f4af78a9add9145c784b58d209e16e"><td class="memTemplParams" colspan="2"><a id="gaf4f4af78a9add9145c784b58d209e16e"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaf4f4af78a9add9145c784b58d209e16e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace_copy_if_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaf4f4af78a9add9145c784b58d209e16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2b15655eb4ca83a6615695d37dc191"><td class="memTemplParams" colspan="2"><a id="gadf2b15655eb4ca83a6615695d37dc191"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gadf2b15655eb4ca83a6615695d37dc191"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gadf2b15655eb4ca83a6615695d37dc191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bff287e5ec676e01a086ac147d4b618"><td class="memTemplParams" colspan="2"><a id="ga7bff287e5ec676e01a086ac147d4b618"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga7bff287e5ec676e01a086ac147d4b618"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::reverse_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga7bff287e5ec676e01a086ac147d4b618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb905dac3fee120cf77b39e821c277c"><td class="memTemplParams" colspan="2"><a id="gaebb905dac3fee120cf77b39e821c277c"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaebb905dac3fee120cf77b39e821c277c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::rotate_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaebb905dac3fee120cf77b39e821c277c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8571d401e506014ea1a86618ca01545f"><td class="memTemplParams" colspan="2"><a id="ga8571d401e506014ea1a86618ca01545f"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga8571d401e506014ea1a86618ca01545f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::sample_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga8571d401e506014ea1a86618ca01545f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e34ec570ccc79f695689635145bed4"><td class="memTemplParams" colspan="2"><a id="ga46e34ec570ccc79f695689635145bed4"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga46e34ec570ccc79f695689635145bed4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_difference_result</b> = detail::in1_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga46e34ec570ccc79f695689635145bed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40276d355563038380b94ca8c500cd2"><td class="memTemplParams" colspan="2"><a id="gaa40276d355563038380b94ca8c500cd2"></a>
template&lt;typename I1 , typename I2 , typename O &gt; </td></tr>
<tr class="memitem:gaa40276d355563038380b94ca8c500cd2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_symmetric_difference_result</b> = detail::in1_in2_out_result&lt; I1, I2, O &gt;</td></tr>
<tr class="separator:gaa40276d355563038380b94ca8c500cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa28c664ec5818d4c1e4458486d109519"><td class="memTemplParams" colspan="2"><a id="gaa28c664ec5818d4c1e4458486d109519"></a>
template&lt;typename I1 , typename I2 , typename O &gt; </td></tr>
<tr class="memitem:gaa28c664ec5818d4c1e4458486d109519"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_union_result</b> = detail::in1_in2_out_result&lt; I1, I2, O &gt;</td></tr>
<tr class="separator:gaa28c664ec5818d4c1e4458486d109519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a91c5c1590ec2c0cf1a56ea2e363dea"><td class="memTemplParams" colspan="2"><a id="ga3a91c5c1590ec2c0cf1a56ea2e363dea"></a>
template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:ga3a91c5c1590ec2c0cf1a56ea2e363dea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::swap_ranges_result</b> = detail::in1_in2_result&lt; I1, I2 &gt;</td></tr>
<tr class="separator:ga3a91c5c1590ec2c0cf1a56ea2e363dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef72d2db7ea1c57f60101e18336e4037"><td class="memTemplParams" colspan="2"><a id="gaef72d2db7ea1c57f60101e18336e4037"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaef72d2db7ea1c57f60101e18336e4037"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::unary_transform_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaef72d2db7ea1c57f60101e18336e4037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7ea4487e401b787c778cbc28e43913d"><td class="memTemplParams" colspan="2"><a id="gaf7ea4487e401b787c778cbc28e43913d"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaf7ea4487e401b787c778cbc28e43913d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::unique_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaf7ea4487e401b787c778cbc28e43913d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9f338eb40255d46cf3bc23880bb9e158"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga9f338eb40255d46cf3bc23880bb9e158"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9f338eb40255d46cf3bc23880bb9e158">ranges::adjacent_find</a> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga9f338eb40255d46cf3bc23880bb9e158"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>adjacent_find</code>  <a href="group__group-algorithms.html#ga9f338eb40255d46cf3bc23880bb9e158">More...</a><br /></td></tr>
<tr class="separator:ga9f338eb40255d46cf3bc23880bb9e158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8995966d9a73963ceef94a1def806afb"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga8995966d9a73963ceef94a1def806afb"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8995966d9a73963ceef94a1def806afb">ranges::adjacent_find</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga8995966d9a73963ceef94a1def806afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga8995966d9a73963ceef94a1def806afb">More...</a><br /></td></tr>
<tr class="separator:ga8995966d9a73963ceef94a1def806afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17787a877c8833e0eb458e5a6a3faaca"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename Pred , typename Proj  = identity&gt; </td></tr>
<tr class="memitem:ga17787a877c8833e0eb458e5a6a3faaca"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga17787a877c8833e0eb458e5a6a3faaca">ranges::adjacent_remove_if</a> (I first, S last, Pred pred={}, Proj proj={})</td></tr>
<tr class="memdesc:ga17787a877c8833e0eb458e5a6a3faaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">function <code>adjacent_remove_if</code>  <a href="group__group-algorithms.html#ga17787a877c8833e0eb458e5a6a3faaca">More...</a><br /></td></tr>
<tr class="separator:ga17787a877c8833e0eb458e5a6a3faaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18c2482a1c31a536469f5aa44a12f35e"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename Pred , typename Proj  = identity&gt; </td></tr>
<tr class="memitem:ga18c2482a1c31a536469f5aa44a12f35e"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga18c2482a1c31a536469f5aa44a12f35e">ranges::adjacent_remove_if</a> (Rng &amp;&amp;rng, Pred pred, Proj proj={})</td></tr>
<tr class="memdesc:ga18c2482a1c31a536469f5aa44a12f35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga18c2482a1c31a536469f5aa44a12f35e">More...</a><br /></td></tr>
<tr class="separator:ga18c2482a1c31a536469f5aa44a12f35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20fa53067b188fd2450ef6aad3399e8a"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga20fa53067b188fd2450ef6aad3399e8a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga20fa53067b188fd2450ef6aad3399e8a">ranges::all_of</a> (I first, S last, F pred, P proj=P{})</td></tr>
<tr class="memdesc:ga20fa53067b188fd2450ef6aad3399e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>all_of</code>  <a href="group__group-algorithms.html#ga20fa53067b188fd2450ef6aad3399e8a">More...</a><br /></td></tr>
<tr class="separator:ga20fa53067b188fd2450ef6aad3399e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10a043d951f87ab620aa7a90d2c638a2"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga10a043d951f87ab620aa7a90d2c638a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga10a043d951f87ab620aa7a90d2c638a2">ranges::all_of</a> (Rng &amp;&amp;rng, F pred, P proj=P{})</td></tr>
<tr class="memdesc:ga10a043d951f87ab620aa7a90d2c638a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga10a043d951f87ab620aa7a90d2c638a2">More...</a><br /></td></tr>
<tr class="separator:ga10a043d951f87ab620aa7a90d2c638a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7962f79cf7e734084c5762f6f2d3e8c5"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga7962f79cf7e734084c5762f6f2d3e8c5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga7962f79cf7e734084c5762f6f2d3e8c5">ranges::any_of</a> (I first, S last, F pred, P proj=P{})</td></tr>
<tr class="memdesc:ga7962f79cf7e734084c5762f6f2d3e8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>any_of</code>  <a href="group__group-algorithms.html#ga7962f79cf7e734084c5762f6f2d3e8c5">More...</a><br /></td></tr>
<tr class="separator:ga7962f79cf7e734084c5762f6f2d3e8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c0d932766db4d6215a3b892349b60a"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gae3c0d932766db4d6215a3b892349b60a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae3c0d932766db4d6215a3b892349b60a">ranges::any_of</a> (Rng &amp;&amp;rng, F pred, P proj=P{})</td></tr>
<tr class="memdesc:gae3c0d932766db4d6215a3b892349b60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gae3c0d932766db4d6215a3b892349b60a">More...</a><br /></td></tr>
<tr class="separator:gae3c0d932766db4d6215a3b892349b60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada2992c6d8624aa4e4103cecc5b71d5e"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gada2992c6d8624aa4e4103cecc5b71d5e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gada2992c6d8624aa4e4103cecc5b71d5e">ranges::binary_search</a> (I first, S last, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gada2992c6d8624aa4e4103cecc5b71d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>binary_search</code>  <a href="group__group-algorithms.html#gada2992c6d8624aa4e4103cecc5b71d5e">More...</a><br /></td></tr>
<tr class="separator:gada2992c6d8624aa4e4103cecc5b71d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8afb8715289bbf439937fc396f330ee"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gac8afb8715289bbf439937fc396f330ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac8afb8715289bbf439937fc396f330ee">ranges::binary_search</a> (Rng &amp;&amp;rng, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gac8afb8715289bbf439937fc396f330ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gac8afb8715289bbf439937fc396f330ee">More...</a><br /></td></tr>
<tr class="separator:gac8afb8715289bbf439937fc396f330ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12a778db69e558efc9306c5c73f74fbd"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga12a778db69e558efc9306c5c73f74fbd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga12a778db69e558efc9306c5c73f74fbd">ranges::contains</a> (I first, S last, const T &amp;val, P proj={})</td></tr>
<tr class="memdesc:ga12a778db69e558efc9306c5c73f74fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>contains</code>  <a href="group__group-algorithms.html#ga12a778db69e558efc9306c5c73f74fbd">More...</a><br /></td></tr>
<tr class="separator:ga12a778db69e558efc9306c5c73f74fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a64319807ba7e276e49f9411c3f6dd1"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga2a64319807ba7e276e49f9411c3f6dd1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga2a64319807ba7e276e49f9411c3f6dd1">ranges::contains</a> (Rng &amp;&amp;rng, const T &amp;val, P proj={})</td></tr>
<tr class="memdesc:ga2a64319807ba7e276e49f9411c3f6dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga2a64319807ba7e276e49f9411c3f6dd1">More...</a><br /></td></tr>
<tr class="separator:ga2a64319807ba7e276e49f9411c3f6dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1663f9fd1985e4095d958b39b0f4f4e"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O &gt; </td></tr>
<tr class="memitem:gac1663f9fd1985e4095d958b39b0f4f4e"><td class="memTemplItemLeft" align="right" valign="top">constexpr copy_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac1663f9fd1985e4095d958b39b0f4f4e">ranges::copy</a> (I first, S last, O out)</td></tr>
<tr class="memdesc:gac1663f9fd1985e4095d958b39b0f4f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy</code>  <a href="group__group-algorithms.html#gac1663f9fd1985e4095d958b39b0f4f4e">More...</a><br /></td></tr>
<tr class="separator:gac1663f9fd1985e4095d958b39b0f4f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1326d7b2387f69dc2ab35ba854691655"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O &gt; </td></tr>
<tr class="memitem:ga1326d7b2387f69dc2ab35ba854691655"><td class="memTemplItemLeft" align="right" valign="top">constexpr copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1326d7b2387f69dc2ab35ba854691655">ranges::copy</a> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="memdesc:ga1326d7b2387f69dc2ab35ba854691655"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga1326d7b2387f69dc2ab35ba854691655">More...</a><br /></td></tr>
<tr class="separator:ga1326d7b2387f69dc2ab35ba854691655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a276d8c27d9c0d6ed6ea7a15dd4610"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O &gt; </td></tr>
<tr class="memitem:ga41a276d8c27d9c0d6ed6ea7a15dd4610"><td class="memTemplItemLeft" align="right" valign="top">copy_backward_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga41a276d8c27d9c0d6ed6ea7a15dd4610">ranges::copy_backward</a> (I first, S end_, O out)</td></tr>
<tr class="memdesc:ga41a276d8c27d9c0d6ed6ea7a15dd4610"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy_backward</code>  <a href="group__group-algorithms.html#ga41a276d8c27d9c0d6ed6ea7a15dd4610">More...</a><br /></td></tr>
<tr class="separator:ga41a276d8c27d9c0d6ed6ea7a15dd4610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76c787c8e4e65676eaaf44113584013"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O &gt; </td></tr>
<tr class="memitem:gad76c787c8e4e65676eaaf44113584013"><td class="memTemplItemLeft" align="right" valign="top">copy_backward_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad76c787c8e4e65676eaaf44113584013">ranges::copy_backward</a> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="memdesc:gad76c787c8e4e65676eaaf44113584013"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gad76c787c8e4e65676eaaf44113584013">More...</a><br /></td></tr>
<tr class="separator:gad76c787c8e4e65676eaaf44113584013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3817fe93ed0a1196bbba995198dd109"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gaf3817fe93ed0a1196bbba995198dd109"><td class="memTemplItemLeft" align="right" valign="top">copy_if_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaf3817fe93ed0a1196bbba995198dd109">ranges::copy_if</a> (I first, S last, O out, F pred, P proj=P{})</td></tr>
<tr class="memdesc:gaf3817fe93ed0a1196bbba995198dd109"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy_if</code>  <a href="group__group-algorithms.html#gaf3817fe93ed0a1196bbba995198dd109">More...</a><br /></td></tr>
<tr class="separator:gaf3817fe93ed0a1196bbba995198dd109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36a0fa6e08d83f6cf93b41faf86b1ad8"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga36a0fa6e08d83f6cf93b41faf86b1ad8"><td class="memTemplItemLeft" align="right" valign="top">copy_if_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga36a0fa6e08d83f6cf93b41faf86b1ad8">ranges::copy_if</a> (Rng &amp;&amp;rng, O out, F pred, P proj=P{})</td></tr>
<tr class="memdesc:ga36a0fa6e08d83f6cf93b41faf86b1ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga36a0fa6e08d83f6cf93b41faf86b1ad8">More...</a><br /></td></tr>
<tr class="separator:ga36a0fa6e08d83f6cf93b41faf86b1ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9388d799b1a2a3e38cba8313cf10242"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename P  = identity&gt; </td></tr>
<tr class="memitem:gab9388d799b1a2a3e38cba8313cf10242"><td class="memTemplItemLeft" align="right" valign="top">copy_n_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab9388d799b1a2a3e38cba8313cf10242">ranges::copy_n</a> (I first, iter_difference_t&lt; I &gt; n, O out)</td></tr>
<tr class="memdesc:gab9388d799b1a2a3e38cba8313cf10242"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy_n</code>  <a href="group__group-algorithms.html#gab9388d799b1a2a3e38cba8313cf10242">More...</a><br /></td></tr>
<tr class="separator:gab9388d799b1a2a3e38cba8313cf10242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd70792bcd1a2402b02ac1ab4ec9e3f3"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename V , typename P  = identity&gt; </td></tr>
<tr class="memitem:gabd70792bcd1a2402b02ac1ab4ec9e3f3"><td class="memTemplItemLeft" align="right" valign="top">iter_difference_t&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gabd70792bcd1a2402b02ac1ab4ec9e3f3">ranges::count</a> (I first, S last, V const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:gabd70792bcd1a2402b02ac1ab4ec9e3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>count</code>  <a href="group__group-algorithms.html#gabd70792bcd1a2402b02ac1ab4ec9e3f3">More...</a><br /></td></tr>
<tr class="separator:gabd70792bcd1a2402b02ac1ab4ec9e3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0caa54ba4075685b569b33b2073668a"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V , typename P  = identity&gt; </td></tr>
<tr class="memitem:gac0caa54ba4075685b569b33b2073668a"><td class="memTemplItemLeft" align="right" valign="top">iter_difference_t&lt; iterator_t&lt; Rng &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac0caa54ba4075685b569b33b2073668a">ranges::count</a> (Rng &amp;&amp;rng, V const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:gac0caa54ba4075685b569b33b2073668a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gac0caa54ba4075685b569b33b2073668a">More...</a><br /></td></tr>
<tr class="separator:gac0caa54ba4075685b569b33b2073668a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54810215f562a3cf1248243591c566d7"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename R , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga54810215f562a3cf1248243591c566d7"><td class="memTemplItemLeft" align="right" valign="top">iter_difference_t&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga54810215f562a3cf1248243591c566d7">ranges::count_if</a> (I first, S last, R pred, P proj=P{})</td></tr>
<tr class="memdesc:ga54810215f562a3cf1248243591c566d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>count_if</code>  <a href="group__group-algorithms.html#ga54810215f562a3cf1248243591c566d7">More...</a><br /></td></tr>
<tr class="separator:ga54810215f562a3cf1248243591c566d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fbe1cf9461e62efd96562d4c25a13c7"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename R , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga6fbe1cf9461e62efd96562d4c25a13c7"><td class="memTemplItemLeft" align="right" valign="top">iter_difference_t&lt; iterator_t&lt; Rng &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga6fbe1cf9461e62efd96562d4c25a13c7">ranges::count_if</a> (Rng &amp;&amp;rng, R pred, P proj=P{})</td></tr>
<tr class="memdesc:ga6fbe1cf9461e62efd96562d4c25a13c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga6fbe1cf9461e62efd96562d4c25a13c7">More...</a><br /></td></tr>
<tr class="separator:ga6fbe1cf9461e62efd96562d4c25a13c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90cf0d62c417da4f3e3ed9a94a795b43"><td class="memTemplParams" colspan="2">template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga90cf0d62c417da4f3e3ed9a94a795b43"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga90cf0d62c417da4f3e3ed9a94a795b43">ranges::ends_with</a> (I0 begin0, S0 end0, I1 begin1, S1 end1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga90cf0d62c417da4f3e3ed9a94a795b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>ends_with</code>  <a href="group__group-algorithms.html#ga90cf0d62c417da4f3e3ed9a94a795b43">More...</a><br /></td></tr>
<tr class="separator:ga90cf0d62c417da4f3e3ed9a94a795b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cf2508147804f574487d05cd3ec7773"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename Rng1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga2cf2508147804f574487d05cd3ec7773"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga2cf2508147804f574487d05cd3ec7773">ranges::ends_with</a> (Rng0 &amp;&amp;rng0, <a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga2cf2508147804f574487d05cd3ec7773"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga2cf2508147804f574487d05cd3ec7773">More...</a><br /></td></tr>
<tr class="separator:ga2cf2508147804f574487d05cd3ec7773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga621fce80ba6d420dd3b61ed697001bd9"><td class="memTemplParams" colspan="2">template&lt;typename I0 , typename S0 , typename I1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga621fce80ba6d420dd3b61ed697001bd9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga621fce80ba6d420dd3b61ed697001bd9">ranges::equal</a> (I0 begin0, S0 end0, I1 begin1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga621fce80ba6d420dd3b61ed697001bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>equal</code>  <a href="group__group-algorithms.html#ga621fce80ba6d420dd3b61ed697001bd9">More...</a><br /></td></tr>
<tr class="separator:ga621fce80ba6d420dd3b61ed697001bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25945a5e9eefc803e0c88435db3a9c80"><td class="memTemplParams" colspan="2">template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga25945a5e9eefc803e0c88435db3a9c80"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga25945a5e9eefc803e0c88435db3a9c80">ranges::equal</a> (I0 begin0, S0 end0, I1 begin1, S1 end1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga25945a5e9eefc803e0c88435db3a9c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga25945a5e9eefc803e0c88435db3a9c80">More...</a><br /></td></tr>
<tr class="separator:ga25945a5e9eefc803e0c88435db3a9c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40640a7e413ef93779f51096f16a88b3"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename I1Ref , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga40640a7e413ef93779f51096f16a88b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga40640a7e413ef93779f51096f16a88b3">ranges::equal</a> (Rng0 &amp;&amp;rng0, I1Ref &amp;&amp;begin1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga40640a7e413ef93779f51096f16a88b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga40640a7e413ef93779f51096f16a88b3">More...</a><br /></td></tr>
<tr class="separator:ga40640a7e413ef93779f51096f16a88b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga796348f9ecfb8077a06e7db8e18ff6e7"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename Rng1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga796348f9ecfb8077a06e7db8e18ff6e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga796348f9ecfb8077a06e7db8e18ff6e7">ranges::equal</a> (Rng0 &amp;&amp;rng0, <a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga796348f9ecfb8077a06e7db8e18ff6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga796348f9ecfb8077a06e7db8e18ff6e7">More...</a><br /></td></tr>
<tr class="separator:ga796348f9ecfb8077a06e7db8e18ff6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga065f5921adf8d8bb16e4e1e7cffe1427"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga065f5921adf8d8bb16e4e1e7cffe1427"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga065f5921adf8d8bb16e4e1e7cffe1427">ranges::equal_range</a> (I first, S last, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga065f5921adf8d8bb16e4e1e7cffe1427"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>equal_range</code>  <a href="group__group-algorithms.html#ga065f5921adf8d8bb16e4e1e7cffe1427">More...</a><br /></td></tr>
<tr class="separator:ga065f5921adf8d8bb16e4e1e7cffe1427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8216954d56c08c873093b610e3c09d1f"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga8216954d56c08c873093b610e3c09d1f"><td class="memTemplItemLeft" align="right" valign="top">borrowed_subrange_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8216954d56c08c873093b610e3c09d1f">ranges::equal_range</a> (Rng &amp;&amp;rng, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga8216954d56c08c873093b610e3c09d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga8216954d56c08c873093b610e3c09d1f">More...</a><br /></td></tr>
<tr class="separator:ga8216954d56c08c873093b610e3c09d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec88f204b6e7be401afc2421011ea22f"><td class="memTemplParams" colspan="2">template&lt;typename O , typename S , typename V &gt; </td></tr>
<tr class="memitem:gaec88f204b6e7be401afc2421011ea22f"><td class="memTemplItemLeft" align="right" valign="top">O&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaec88f204b6e7be401afc2421011ea22f">ranges::fill</a> (O first, S last, V const &amp;val)</td></tr>
<tr class="memdesc:gaec88f204b6e7be401afc2421011ea22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>fill</code>  <a href="group__group-algorithms.html#gaec88f204b6e7be401afc2421011ea22f">More...</a><br /></td></tr>
<tr class="separator:gaec88f204b6e7be401afc2421011ea22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7163c7732174455f295f7d1437f072a1"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V &gt; </td></tr>
<tr class="memitem:ga7163c7732174455f295f7d1437f072a1"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga7163c7732174455f295f7d1437f072a1">ranges::fill</a> (Rng &amp;&amp;rng, V const &amp;val)</td></tr>
<tr class="memdesc:ga7163c7732174455f295f7d1437f072a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga7163c7732174455f295f7d1437f072a1">More...</a><br /></td></tr>
<tr class="separator:ga7163c7732174455f295f7d1437f072a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f04fdbc6e4b411e565832b64c9f9df"><td class="memTemplParams" colspan="2">template&lt;typename O , typename V &gt; </td></tr>
<tr class="memitem:ga78f04fdbc6e4b411e565832b64c9f9df"><td class="memTemplItemLeft" align="right" valign="top">O&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga78f04fdbc6e4b411e565832b64c9f9df">ranges::fill_n</a> (O first, iter_difference_t&lt; O &gt; n, V const &amp;val)</td></tr>
<tr class="memdesc:ga78f04fdbc6e4b411e565832b64c9f9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>equal</code>  <a href="group__group-algorithms.html#ga78f04fdbc6e4b411e565832b64c9f9df">More...</a><br /></td></tr>
<tr class="separator:ga78f04fdbc6e4b411e565832b64c9f9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d8e4a9998178c6c21c7bd2683cab4ce"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename V , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga1d8e4a9998178c6c21c7bd2683cab4ce"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1d8e4a9998178c6c21c7bd2683cab4ce">ranges::find</a> (I first, S last, V const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:ga1d8e4a9998178c6c21c7bd2683cab4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>find</code>  <a href="group__group-algorithms.html#ga1d8e4a9998178c6c21c7bd2683cab4ce">More...</a><br /></td></tr>
<tr class="separator:ga1d8e4a9998178c6c21c7bd2683cab4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08e617e1003f24a0cf9e25119fded9e8"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga08e617e1003f24a0cf9e25119fded9e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga08e617e1003f24a0cf9e25119fded9e8">ranges::find</a> (Rng &amp;&amp;rng, V const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:ga08e617e1003f24a0cf9e25119fded9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga08e617e1003f24a0cf9e25119fded9e8">More...</a><br /></td></tr>
<tr class="separator:ga08e617e1003f24a0cf9e25119fded9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03f0f8c9bcb0559fbb0dd40255d913d5"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename R  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga03f0f8c9bcb0559fbb0dd40255d913d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga03f0f8c9bcb0559fbb0dd40255d913d5">ranges::find_end</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, R pred=R{}, P proj=P{})</td></tr>
<tr class="memdesc:ga03f0f8c9bcb0559fbb0dd40255d913d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>find_end</code>  <a href="group__group-algorithms.html#ga03f0f8c9bcb0559fbb0dd40255d913d5">More...</a><br /></td></tr>
<tr class="separator:ga03f0f8c9bcb0559fbb0dd40255d913d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa63967ca547c5eb02bdce496f431baa1"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename R  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaa63967ca547c5eb02bdce496f431baa1"><td class="memTemplItemLeft" align="right" valign="top">borrowed_subrange_t&lt; <a class="el" href="class_rng1.html">Rng1</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa63967ca547c5eb02bdce496f431baa1">ranges::find_end</a> (<a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;rng2, R pred=R{}, P proj=P{})</td></tr>
<tr class="memdesc:gaa63967ca547c5eb02bdce496f431baa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gaa63967ca547c5eb02bdce496f431baa1">More...</a><br /></td></tr>
<tr class="separator:gaa63967ca547c5eb02bdce496f431baa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab988e235a1c284d69a91f3c7faa05265"><td class="memTemplParams" colspan="2">template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename R  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:gab988e235a1c284d69a91f3c7faa05265"><td class="memTemplItemLeft" align="right" valign="top">constexpr I0&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab988e235a1c284d69a91f3c7faa05265">ranges::find_first_of</a> (I0 begin0, S0 end0, I1 begin1, S1 end1, R pred=R{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:gab988e235a1c284d69a91f3c7faa05265"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>find_first_of</code>  <a href="group__group-algorithms.html#gab988e235a1c284d69a91f3c7faa05265">More...</a><br /></td></tr>
<tr class="separator:gab988e235a1c284d69a91f3c7faa05265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b5cacc679ba0e755519252a6f4f15cd"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename Rng1 , typename R  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga5b5cacc679ba0e755519252a6f4f15cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga5b5cacc679ba0e755519252a6f4f15cd">ranges::find_first_of</a> (Rng0 &amp;&amp;rng0, <a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, R pred=R{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga5b5cacc679ba0e755519252a6f4f15cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga5b5cacc679ba0e755519252a6f4f15cd">More...</a><br /></td></tr>
<tr class="separator:ga5b5cacc679ba0e755519252a6f4f15cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21556995847a86ff6ce62a5f8ab5a8b"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gae21556995847a86ff6ce62a5f8ab5a8b"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae21556995847a86ff6ce62a5f8ab5a8b">ranges::find_if</a> (I first, S last, F pred, P proj=P{})</td></tr>
<tr class="memdesc:gae21556995847a86ff6ce62a5f8ab5a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>find</code>  <a href="group__group-algorithms.html#gae21556995847a86ff6ce62a5f8ab5a8b">More...</a><br /></td></tr>
<tr class="separator:gae21556995847a86ff6ce62a5f8ab5a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c615adb2ae6c22dbef6d3e9862964b9"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga1c615adb2ae6c22dbef6d3e9862964b9"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1c615adb2ae6c22dbef6d3e9862964b9">ranges::find_if</a> (Rng &amp;&amp;rng, F pred, P proj=P{})</td></tr>
<tr class="memdesc:ga1c615adb2ae6c22dbef6d3e9862964b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga1c615adb2ae6c22dbef6d3e9862964b9">More...</a><br /></td></tr>
<tr class="separator:ga1c615adb2ae6c22dbef6d3e9862964b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac08351568fba29a2a2ee2b0ef8822450"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gac08351568fba29a2a2ee2b0ef8822450"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac08351568fba29a2a2ee2b0ef8822450">ranges::find_if_not</a> (I first, S last, F pred, P proj=P{})</td></tr>
<tr class="memdesc:gac08351568fba29a2a2ee2b0ef8822450"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>find_if_not</code>  <a href="group__group-algorithms.html#gac08351568fba29a2a2ee2b0ef8822450">More...</a><br /></td></tr>
<tr class="separator:gac08351568fba29a2a2ee2b0ef8822450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae352ef5e361b81eb7e1a05e8d3b3504"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gaae352ef5e361b81eb7e1a05e8d3b3504"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaae352ef5e361b81eb7e1a05e8d3b3504">ranges::find_if_not</a> (Rng &amp;&amp;rng, F pred, P proj=P{})</td></tr>
<tr class="memdesc:gaae352ef5e361b81eb7e1a05e8d3b3504"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gaae352ef5e361b81eb7e1a05e8d3b3504">More...</a><br /></td></tr>
<tr class="separator:gaae352ef5e361b81eb7e1a05e8d3b3504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c75ca4aaf36d30c1122f51db99d505"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gae3c75ca4aaf36d30c1122f51db99d505"><td class="memTemplItemLeft" align="right" valign="top">for_each_result&lt; I, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae3c75ca4aaf36d30c1122f51db99d505">ranges::for_each</a> (I first, S last, F fun, P proj=P{})</td></tr>
<tr class="memdesc:gae3c75ca4aaf36d30c1122f51db99d505"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>for_each</code>  <a href="group__group-algorithms.html#gae3c75ca4aaf36d30c1122f51db99d505">More...</a><br /></td></tr>
<tr class="separator:gae3c75ca4aaf36d30c1122f51db99d505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac74c95463754807206a1a1432eb20368"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gac74c95463754807206a1a1432eb20368"><td class="memTemplItemLeft" align="right" valign="top">for_each_result&lt; borrowed_iterator_t&lt; Rng &gt;, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac74c95463754807206a1a1432eb20368">ranges::for_each</a> (Rng &amp;&amp;rng, F fun, P proj=P{})</td></tr>
<tr class="memdesc:gac74c95463754807206a1a1432eb20368"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gac74c95463754807206a1a1432eb20368">More...</a><br /></td></tr>
<tr class="separator:gac74c95463754807206a1a1432eb20368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0040ffc33d08505809fffa5aea8c9103"><td class="memTemplParams" colspan="2">template&lt;typename I , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga0040ffc33d08505809fffa5aea8c9103"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0040ffc33d08505809fffa5aea8c9103">ranges::for_each_n</a> (I first, iter_difference_t&lt; I &gt; n, F fun, P proj=P{})</td></tr>
<tr class="memdesc:ga0040ffc33d08505809fffa5aea8c9103"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>for_each_n</code>  <a href="group__group-algorithms.html#ga0040ffc33d08505809fffa5aea8c9103">More...</a><br /></td></tr>
<tr class="separator:ga0040ffc33d08505809fffa5aea8c9103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12cc578de361ba8aea4c3efc9181bdaf"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga12cc578de361ba8aea4c3efc9181bdaf"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga12cc578de361ba8aea4c3efc9181bdaf">ranges::for_each_n</a> (Rng &amp;&amp;rng, range_difference_t&lt; Rng &gt; n, F fun, P proj=P{})</td></tr>
<tr class="memdesc:ga12cc578de361ba8aea4c3efc9181bdaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga12cc578de361ba8aea4c3efc9181bdaf">More...</a><br /></td></tr>
<tr class="separator:ga12cc578de361ba8aea4c3efc9181bdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3b351c6b515474d913cf3054cacba2d"><td class="memTemplParams" colspan="2">template&lt;typename O , typename S , typename F &gt; </td></tr>
<tr class="memitem:gab3b351c6b515474d913cf3054cacba2d"><td class="memTemplItemLeft" align="right" valign="top">generate_result&lt; O, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab3b351c6b515474d913cf3054cacba2d">ranges::generate</a> (O first, S last, F fun)</td></tr>
<tr class="memdesc:gab3b351c6b515474d913cf3054cacba2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>generate_n</code>  <a href="group__group-algorithms.html#gab3b351c6b515474d913cf3054cacba2d">More...</a><br /></td></tr>
<tr class="separator:gab3b351c6b515474d913cf3054cacba2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8299db3094590afff7a963e2bba9cb9a"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F &gt; </td></tr>
<tr class="memitem:ga8299db3094590afff7a963e2bba9cb9a"><td class="memTemplItemLeft" align="right" valign="top">generate_result&lt; borrowed_iterator_t&lt; Rng &gt;, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8299db3094590afff7a963e2bba9cb9a">ranges::generate</a> (Rng &amp;&amp;rng, F fun)</td></tr>
<tr class="memdesc:ga8299db3094590afff7a963e2bba9cb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga8299db3094590afff7a963e2bba9cb9a">More...</a><br /></td></tr>
<tr class="separator:ga8299db3094590afff7a963e2bba9cb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga248c2ba6e27f05e9737df5baa2612d33"><td class="memTemplParams" colspan="2">template&lt;typename O , typename F &gt; </td></tr>
<tr class="memitem:ga248c2ba6e27f05e9737df5baa2612d33"><td class="memTemplItemLeft" align="right" valign="top">generate_n_result&lt; O, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga248c2ba6e27f05e9737df5baa2612d33">ranges::generate_n</a> (O first, iter_difference_t&lt; O &gt; n, F fun)</td></tr>
<tr class="memdesc:ga248c2ba6e27f05e9737df5baa2612d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>generate_n</code>  <a href="group__group-algorithms.html#ga248c2ba6e27f05e9737df5baa2612d33">More...</a><br /></td></tr>
<tr class="separator:ga248c2ba6e27f05e9737df5baa2612d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d45f4d8cc9d64ca2d50599557dda022"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga0d45f4d8cc9d64ca2d50599557dda022"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0d45f4d8cc9d64ca2d50599557dda022">ranges::includes</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga0d45f4d8cc9d64ca2d50599557dda022"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>includes</code>  <a href="group__group-algorithms.html#ga0d45f4d8cc9d64ca2d50599557dda022">More...</a><br /></td></tr>
<tr class="separator:ga0d45f4d8cc9d64ca2d50599557dda022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a0bd1b89f2e0ff2accb96348a8191d9"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga4a0bd1b89f2e0ff2accb96348a8191d9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga4a0bd1b89f2e0ff2accb96348a8191d9">ranges::includes</a> (<a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;rng2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga4a0bd1b89f2e0ff2accb96348a8191d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga4a0bd1b89f2e0ff2accb96348a8191d9">More...</a><br /></td></tr>
<tr class="separator:ga4a0bd1b89f2e0ff2accb96348a8191d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69be23f01a954678edc58683dd2b4f7f"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga69be23f01a954678edc58683dd2b4f7f"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga69be23f01a954678edc58683dd2b4f7f">ranges::inplace_merge</a> (I first, I middle, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga69be23f01a954678edc58683dd2b4f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>inplace_merge</code>  <a href="group__group-algorithms.html#ga69be23f01a954678edc58683dd2b4f7f">More...</a><br /></td></tr>
<tr class="separator:ga69be23f01a954678edc58683dd2b4f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d8910229da062514994ec67724fa90"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gac5d8910229da062514994ec67724fa90"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac5d8910229da062514994ec67724fa90">ranges::inplace_merge</a> (Rng &amp;&amp;rng, iterator_t&lt; Rng &gt; middle, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gac5d8910229da062514994ec67724fa90"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gac5d8910229da062514994ec67724fa90">More...</a><br /></td></tr>
<tr class="separator:gac5d8910229da062514994ec67724fa90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga474185e41e367f882df757dd9cc768b2"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga474185e41e367f882df757dd9cc768b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga474185e41e367f882df757dd9cc768b2">ranges::is_heap</a> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga474185e41e367f882df757dd9cc768b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>is_heap</code>  <a href="group__group-algorithms.html#ga474185e41e367f882df757dd9cc768b2">More...</a><br /></td></tr>
<tr class="separator:ga474185e41e367f882df757dd9cc768b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga735cff63efdf19dc2dc4123fd24899d7"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga735cff63efdf19dc2dc4123fd24899d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga735cff63efdf19dc2dc4123fd24899d7">ranges::is_heap</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga735cff63efdf19dc2dc4123fd24899d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga735cff63efdf19dc2dc4123fd24899d7">More...</a><br /></td></tr>
<tr class="separator:ga735cff63efdf19dc2dc4123fd24899d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ad0398ff5571b8c1ce52d3704d2ce6a"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga1ad0398ff5571b8c1ce52d3704d2ce6a"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1ad0398ff5571b8c1ce52d3704d2ce6a">ranges::is_heap_until</a> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga1ad0398ff5571b8c1ce52d3704d2ce6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>is_heap_until</code>  <a href="group__group-algorithms.html#ga1ad0398ff5571b8c1ce52d3704d2ce6a">More...</a><br /></td></tr>
<tr class="separator:ga1ad0398ff5571b8c1ce52d3704d2ce6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a4a82bdf4ade758e2b78415bda5b982"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga4a4a82bdf4ade758e2b78415bda5b982"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga4a4a82bdf4ade758e2b78415bda5b982">ranges::is_heap_until</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga4a4a82bdf4ade758e2b78415bda5b982"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga4a4a82bdf4ade758e2b78415bda5b982">More...</a><br /></td></tr>
<tr class="separator:ga4a4a82bdf4ade758e2b78415bda5b982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1612e6e4cf8c166a994ae78c04f0572"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:gaa1612e6e4cf8c166a994ae78c04f0572"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa1612e6e4cf8c166a994ae78c04f0572">ranges::is_partitioned</a> (I first, S last, C pred, P proj=P{})</td></tr>
<tr class="memdesc:gaa1612e6e4cf8c166a994ae78c04f0572"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>is_partitioned</code>  <a href="group__group-algorithms.html#gaa1612e6e4cf8c166a994ae78c04f0572">More...</a><br /></td></tr>
<tr class="separator:gaa1612e6e4cf8c166a994ae78c04f0572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga641b741cfd1cf9e4c095e86b747ead80"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga641b741cfd1cf9e4c095e86b747ead80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga641b741cfd1cf9e4c095e86b747ead80">ranges::is_partitioned</a> (Rng &amp;&amp;rng, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga641b741cfd1cf9e4c095e86b747ead80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga641b741cfd1cf9e4c095e86b747ead80">More...</a><br /></td></tr>
<tr class="separator:ga641b741cfd1cf9e4c095e86b747ead80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace8e1df9f2c8c5c1a0afb8fb9dfe812e"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gace8e1df9f2c8c5c1a0afb8fb9dfe812e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gace8e1df9f2c8c5c1a0afb8fb9dfe812e">ranges::is_permutation</a> (I1 begin1, S1 end1, I2 begin2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gace8e1df9f2c8c5c1a0afb8fb9dfe812e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>is_permutation</code>  <a href="group__group-algorithms.html#gace8e1df9f2c8c5c1a0afb8fb9dfe812e">More...</a><br /></td></tr>
<tr class="separator:gace8e1df9f2c8c5c1a0afb8fb9dfe812e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a6c585adfd745b93984902ccc873c8a"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga6a6c585adfd745b93984902ccc873c8a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga6a6c585adfd745b93984902ccc873c8a">ranges::is_permutation</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga6a6c585adfd745b93984902ccc873c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga6a6c585adfd745b93984902ccc873c8a">More...</a><br /></td></tr>
<tr class="separator:ga6a6c585adfd745b93984902ccc873c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1b063fb051f167be4b775324af35217"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename I2Ref , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gaa1b063fb051f167be4b775324af35217"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa1b063fb051f167be4b775324af35217">ranges::is_permutation</a> (<a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, I2Ref &amp;&amp;begin2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gaa1b063fb051f167be4b775324af35217"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gaa1b063fb051f167be4b775324af35217">More...</a><br /></td></tr>
<tr class="separator:gaa1b063fb051f167be4b775324af35217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e799a1d75267d3fc2764c4d6e16e43f"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga8e799a1d75267d3fc2764c4d6e16e43f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8e799a1d75267d3fc2764c4d6e16e43f">ranges::is_permutation</a> (<a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;rng2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga8e799a1d75267d3fc2764c4d6e16e43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga8e799a1d75267d3fc2764c4d6e16e43f">More...</a><br /></td></tr>
<tr class="separator:ga8e799a1d75267d3fc2764c4d6e16e43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad73a64c5b5fac2100034b2af5654f876"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename R  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gad73a64c5b5fac2100034b2af5654f876"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad73a64c5b5fac2100034b2af5654f876">ranges::is_sorted</a> (I first, S last, R rel=R{}, P proj=P{})</td></tr>
<tr class="memdesc:gad73a64c5b5fac2100034b2af5654f876"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>is_sorted</code>  <a href="group__group-algorithms.html#gad73a64c5b5fac2100034b2af5654f876">More...</a><br /></td></tr>
<tr class="separator:gad73a64c5b5fac2100034b2af5654f876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767102d6d607a8e22afea5145987511e"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename R  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga767102d6d607a8e22afea5145987511e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga767102d6d607a8e22afea5145987511e">ranges::is_sorted</a> (Rng &amp;&amp;rng, R rel=R{}, P proj=P{})</td></tr>
<tr class="memdesc:ga767102d6d607a8e22afea5145987511e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga767102d6d607a8e22afea5145987511e">More...</a><br /></td></tr>
<tr class="separator:ga767102d6d607a8e22afea5145987511e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa315dfc9c44126707ff144552e7236cf"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename R  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaa315dfc9c44126707ff144552e7236cf"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa315dfc9c44126707ff144552e7236cf">ranges::is_sorted_until</a> (I first, S last, R pred=R{}, P proj=P{})</td></tr>
<tr class="memdesc:gaa315dfc9c44126707ff144552e7236cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>is_sorted_until</code>  <a href="group__group-algorithms.html#gaa315dfc9c44126707ff144552e7236cf">More...</a><br /></td></tr>
<tr class="separator:gaa315dfc9c44126707ff144552e7236cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f56b8373932148bb8eace8f3f9dee6c"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename R  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga9f56b8373932148bb8eace8f3f9dee6c"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9f56b8373932148bb8eace8f3f9dee6c">ranges::is_sorted_until</a> (Rng &amp;&amp;rng, R pred=R{}, P proj=P{})</td></tr>
<tr class="memdesc:ga9f56b8373932148bb8eace8f3f9dee6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga9f56b8373932148bb8eace8f3f9dee6c">More...</a><br /></td></tr>
<tr class="separator:ga9f56b8373932148bb8eace8f3f9dee6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c748435b0fff2d24e76bc08a97b10c7"><td class="memTemplParams" colspan="2">template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename C  = less, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga2c748435b0fff2d24e76bc08a97b10c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga2c748435b0fff2d24e76bc08a97b10c7">ranges::lexicographical_compare</a> (I0 begin0, S0 end0, I1 begin1, S1 end1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga2c748435b0fff2d24e76bc08a97b10c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>lexicographical_compare</code>  <a href="group__group-algorithms.html#ga2c748435b0fff2d24e76bc08a97b10c7">More...</a><br /></td></tr>
<tr class="separator:ga2c748435b0fff2d24e76bc08a97b10c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga136e96f17657d77a6259d87c70e048e7"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename Rng1 , typename C  = less, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga136e96f17657d77a6259d87c70e048e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga136e96f17657d77a6259d87c70e048e7">ranges::lexicographical_compare</a> (Rng0 &amp;&amp;rng0, <a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga136e96f17657d77a6259d87c70e048e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga136e96f17657d77a6259d87c70e048e7">More...</a><br /></td></tr>
<tr class="separator:ga136e96f17657d77a6259d87c70e048e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadac559e70dbb049bbb03be98039e2114"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gadac559e70dbb049bbb03be98039e2114"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gadac559e70dbb049bbb03be98039e2114">ranges::lower_bound</a> (I first, S last, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gadac559e70dbb049bbb03be98039e2114"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>lower_bound</code>  <a href="group__group-algorithms.html#gadac559e70dbb049bbb03be98039e2114">More...</a><br /></td></tr>
<tr class="separator:gadac559e70dbb049bbb03be98039e2114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga660e7a35e981781951b4de7fff544802"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga660e7a35e981781951b4de7fff544802"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga660e7a35e981781951b4de7fff544802">ranges::lower_bound</a> (Rng &amp;&amp;rng, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga660e7a35e981781951b4de7fff544802"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga660e7a35e981781951b4de7fff544802">More...</a><br /></td></tr>
<tr class="separator:ga660e7a35e981781951b4de7fff544802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga262acf8b1a6f9d0bfd35a20fcb474c51"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga262acf8b1a6f9d0bfd35a20fcb474c51"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga262acf8b1a6f9d0bfd35a20fcb474c51">ranges::make_heap</a> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga262acf8b1a6f9d0bfd35a20fcb474c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>make_heap</code>  <a href="group__group-algorithms.html#ga262acf8b1a6f9d0bfd35a20fcb474c51">More...</a><br /></td></tr>
<tr class="separator:ga262acf8b1a6f9d0bfd35a20fcb474c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab268c150c78da5990cfcce27bfd26d65"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gab268c150c78da5990cfcce27bfd26d65"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab268c150c78da5990cfcce27bfd26d65">ranges::make_heap</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gab268c150c78da5990cfcce27bfd26d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gab268c150c78da5990cfcce27bfd26d65">More...</a><br /></td></tr>
<tr class="separator:gab268c150c78da5990cfcce27bfd26d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb7f0a7eb4226d8d0550bcf49016216"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga7cb7f0a7eb4226d8d0550bcf49016216"><td class="memTemplItemLeft" align="right" valign="top">constexpr range_value_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga7cb7f0a7eb4226d8d0550bcf49016216">ranges::max</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga7cb7f0a7eb4226d8d0550bcf49016216"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga7cb7f0a7eb4226d8d0550bcf49016216">More...</a><br /></td></tr>
<tr class="separator:ga7cb7f0a7eb4226d8d0550bcf49016216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga557aae406d07b1b8a5f9edbac03721fe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga557aae406d07b1b8a5f9edbac03721fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga557aae406d07b1b8a5f9edbac03721fe">ranges::max</a> (std::initializer_list&lt; T &gt; const &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga557aae406d07b1b8a5f9edbac03721fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga557aae406d07b1b8a5f9edbac03721fe">More...</a><br /></td></tr>
<tr class="separator:ga557aae406d07b1b8a5f9edbac03721fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81c8fc3325290fecf6048b61878f6e99"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga81c8fc3325290fecf6048b61878f6e99"><td class="memTemplItemLeft" align="right" valign="top">constexpr T const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga81c8fc3325290fecf6048b61878f6e99">ranges::max</a> (T const &amp;a, T const &amp;b, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga81c8fc3325290fecf6048b61878f6e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>max</code>  <a href="group__group-algorithms.html#ga81c8fc3325290fecf6048b61878f6e99">More...</a><br /></td></tr>
<tr class="separator:ga81c8fc3325290fecf6048b61878f6e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac318ca1ff2aac7fbd59c306724654159"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gac318ca1ff2aac7fbd59c306724654159"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac318ca1ff2aac7fbd59c306724654159">ranges::max_element</a> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gac318ca1ff2aac7fbd59c306724654159"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>max_element</code>  <a href="group__group-algorithms.html#gac318ca1ff2aac7fbd59c306724654159">More...</a><br /></td></tr>
<tr class="separator:gac318ca1ff2aac7fbd59c306724654159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e2ede6a46d969e81364ec4eb8a2467"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga72e2ede6a46d969e81364ec4eb8a2467"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga72e2ede6a46d969e81364ec4eb8a2467">ranges::max_element</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga72e2ede6a46d969e81364ec4eb8a2467"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga72e2ede6a46d969e81364ec4eb8a2467">More...</a><br /></td></tr>
<tr class="separator:ga72e2ede6a46d969e81364ec4eb8a2467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9cc8e9a2bb6414d2c7df94a09be3e3"><td class="memTemplParams" colspan="2">template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename O , typename C  = less, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:gaeb9cc8e9a2bb6414d2c7df94a09be3e3"><td class="memTemplItemLeft" align="right" valign="top">merge_result&lt; I0, I1, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaeb9cc8e9a2bb6414d2c7df94a09be3e3">ranges::merge</a> (I0 begin0, S0 end0, I1 begin1, S1 end1, O out, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:gaeb9cc8e9a2bb6414d2c7df94a09be3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>merge</code>  <a href="group__group-algorithms.html#gaeb9cc8e9a2bb6414d2c7df94a09be3e3">More...</a><br /></td></tr>
<tr class="separator:gaeb9cc8e9a2bb6414d2c7df94a09be3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76bb637f6b8c0899daf6431f669ea385"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename Rng1 , typename O , typename C  = less, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga76bb637f6b8c0899daf6431f669ea385"><td class="memTemplItemLeft" align="right" valign="top">merge_result&lt; borrowed_iterator_t&lt; Rng0 &gt;, borrowed_iterator_t&lt; <a class="el" href="class_rng1.html">Rng1</a> &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga76bb637f6b8c0899daf6431f669ea385">ranges::merge</a> (Rng0 &amp;&amp;rng0, <a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, O out, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga76bb637f6b8c0899daf6431f669ea385"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga76bb637f6b8c0899daf6431f669ea385">More...</a><br /></td></tr>
<tr class="separator:ga76bb637f6b8c0899daf6431f669ea385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga201c55750b7ffaf8f3bf707cb79f7b69"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga201c55750b7ffaf8f3bf707cb79f7b69"><td class="memTemplItemLeft" align="right" valign="top">constexpr range_value_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga201c55750b7ffaf8f3bf707cb79f7b69">ranges::min</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga201c55750b7ffaf8f3bf707cb79f7b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga201c55750b7ffaf8f3bf707cb79f7b69">More...</a><br /></td></tr>
<tr class="separator:ga201c55750b7ffaf8f3bf707cb79f7b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebe356f1f4c0826477e74c34f54d9c8f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaebe356f1f4c0826477e74c34f54d9c8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaebe356f1f4c0826477e74c34f54d9c8f">ranges::min</a> (std::initializer_list&lt; T &gt; const &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gaebe356f1f4c0826477e74c34f54d9c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gaebe356f1f4c0826477e74c34f54d9c8f">More...</a><br /></td></tr>
<tr class="separator:gaebe356f1f4c0826477e74c34f54d9c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f3fae929128282a29d51fa452f2fc16"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga6f3fae929128282a29d51fa452f2fc16"><td class="memTemplItemLeft" align="right" valign="top">constexpr T const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga6f3fae929128282a29d51fa452f2fc16">ranges::min</a> (T const &amp;a, T const &amp;b, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga6f3fae929128282a29d51fa452f2fc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>min</code>  <a href="group__group-algorithms.html#ga6f3fae929128282a29d51fa452f2fc16">More...</a><br /></td></tr>
<tr class="separator:ga6f3fae929128282a29d51fa452f2fc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb04fb9206e52dcd5a8bbfa2084146b7"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gacb04fb9206e52dcd5a8bbfa2084146b7"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gacb04fb9206e52dcd5a8bbfa2084146b7">ranges::min_element</a> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gacb04fb9206e52dcd5a8bbfa2084146b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>min_element</code>  <a href="group__group-algorithms.html#gacb04fb9206e52dcd5a8bbfa2084146b7">More...</a><br /></td></tr>
<tr class="separator:gacb04fb9206e52dcd5a8bbfa2084146b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21e15bfbd4bbba21618c55c873486684"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga21e15bfbd4bbba21618c55c873486684"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga21e15bfbd4bbba21618c55c873486684">ranges::min_element</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga21e15bfbd4bbba21618c55c873486684"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga21e15bfbd4bbba21618c55c873486684">More...</a><br /></td></tr>
<tr class="separator:ga21e15bfbd4bbba21618c55c873486684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d3a1dad8f5b506eb9d437d82205609"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga88d3a1dad8f5b506eb9d437d82205609"><td class="memTemplItemLeft" align="right" valign="top">constexpr minmax_result&lt; range_value_t&lt; Rng &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga88d3a1dad8f5b506eb9d437d82205609">ranges::minmax</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga88d3a1dad8f5b506eb9d437d82205609"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga88d3a1dad8f5b506eb9d437d82205609">More...</a><br /></td></tr>
<tr class="separator:ga88d3a1dad8f5b506eb9d437d82205609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffdee79083e3876c7562153203673fb8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaffdee79083e3876c7562153203673fb8"><td class="memTemplItemLeft" align="right" valign="top">constexpr minmax_result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaffdee79083e3876c7562153203673fb8">ranges::minmax</a> (std::initializer_list&lt; T &gt; const &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gaffdee79083e3876c7562153203673fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gaffdee79083e3876c7562153203673fb8">More...</a><br /></td></tr>
<tr class="separator:gaffdee79083e3876c7562153203673fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20cd213410245835bdafb2e6eb996895"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga20cd213410245835bdafb2e6eb996895"><td class="memTemplItemLeft" align="right" valign="top">constexpr minmax_result&lt; T const &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga20cd213410245835bdafb2e6eb996895">ranges::minmax</a> (T const &amp;a, T const &amp;b, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga20cd213410245835bdafb2e6eb996895"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>minmax</code>  <a href="group__group-algorithms.html#ga20cd213410245835bdafb2e6eb996895">More...</a><br /></td></tr>
<tr class="separator:ga20cd213410245835bdafb2e6eb996895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdaf4d2ee6602188897c4bed53c717fc"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gabdaf4d2ee6602188897c4bed53c717fc"><td class="memTemplItemLeft" align="right" valign="top">minmax_element_result&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gabdaf4d2ee6602188897c4bed53c717fc">ranges::minmax_element</a> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gabdaf4d2ee6602188897c4bed53c717fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>minmax_element</code>  <a href="group__group-algorithms.html#gabdaf4d2ee6602188897c4bed53c717fc">More...</a><br /></td></tr>
<tr class="separator:gabdaf4d2ee6602188897c4bed53c717fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043d5fb1cf4ae4823bfa6d9694dea74a"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga043d5fb1cf4ae4823bfa6d9694dea74a"><td class="memTemplItemLeft" align="right" valign="top">minmax_element_result&lt; borrowed_iterator_t&lt; Rng &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga043d5fb1cf4ae4823bfa6d9694dea74a">ranges::minmax_element</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga043d5fb1cf4ae4823bfa6d9694dea74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga043d5fb1cf4ae4823bfa6d9694dea74a">More...</a><br /></td></tr>
<tr class="separator:ga043d5fb1cf4ae4823bfa6d9694dea74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed939edaa257e1915717af8a2cad2874"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gaed939edaa257e1915717af8a2cad2874"><td class="memTemplItemLeft" align="right" valign="top">mismatch_result&lt; I1, I2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaed939edaa257e1915717af8a2cad2874">ranges::mismatch</a> (I1 begin1, S1 end1, I2 begin2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gaed939edaa257e1915717af8a2cad2874"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>mismatch</code>  <a href="group__group-algorithms.html#gaed939edaa257e1915717af8a2cad2874">More...</a><br /></td></tr>
<tr class="separator:gaed939edaa257e1915717af8a2cad2874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad99c5ed9f1a8ac6b7b28b6101ce0c55"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gaad99c5ed9f1a8ac6b7b28b6101ce0c55"><td class="memTemplItemLeft" align="right" valign="top">mismatch_result&lt; I1, I2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaad99c5ed9f1a8ac6b7b28b6101ce0c55">ranges::mismatch</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gaad99c5ed9f1a8ac6b7b28b6101ce0c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gaad99c5ed9f1a8ac6b7b28b6101ce0c55">More...</a><br /></td></tr>
<tr class="separator:gaad99c5ed9f1a8ac6b7b28b6101ce0c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga718d680974a506935ea342f44fd535a2"><td class="memTemplParams" colspan="2"><a id="ga718d680974a506935ea342f44fd535a2"></a>
template&lt;typename Rng1 , typename I2Ref , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga718d680974a506935ea342f44fd535a2"><td class="memTemplItemLeft" align="right" valign="top">mismatch_result&lt; borrowed_iterator_t&lt; <a class="el" href="class_rng1.html">Rng1</a> &gt;, uncvref_t&lt; I2Ref &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga718d680974a506935ea342f44fd535a2">ranges::mismatch</a> (<a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, I2Ref &amp;&amp;begin2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga718d680974a506935ea342f44fd535a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga718d680974a506935ea342f44fd535a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53d1762ffef58449321c655da78c52cc"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga53d1762ffef58449321c655da78c52cc"><td class="memTemplItemLeft" align="right" valign="top">mismatch_result&lt; borrowed_iterator_t&lt; <a class="el" href="class_rng1.html">Rng1</a> &gt;, borrowed_iterator_t&lt; <a class="el" href="class_rng2.html">Rng2</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga53d1762ffef58449321c655da78c52cc">ranges::mismatch</a> (<a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;rng2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga53d1762ffef58449321c655da78c52cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga53d1762ffef58449321c655da78c52cc">More...</a><br /></td></tr>
<tr class="separator:ga53d1762ffef58449321c655da78c52cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7934e0a0e37148a7b0ba6ea1767c2471"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O &gt; </td></tr>
<tr class="memitem:ga7934e0a0e37148a7b0ba6ea1767c2471"><td class="memTemplItemLeft" align="right" valign="top">move_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga7934e0a0e37148a7b0ba6ea1767c2471">ranges::move</a> (I first, S last, O out)</td></tr>
<tr class="memdesc:ga7934e0a0e37148a7b0ba6ea1767c2471"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>move</code>  <a href="group__group-algorithms.html#ga7934e0a0e37148a7b0ba6ea1767c2471">More...</a><br /></td></tr>
<tr class="separator:ga7934e0a0e37148a7b0ba6ea1767c2471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74247b371dbb7594cc424f0f13e4b614"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O &gt; </td></tr>
<tr class="memitem:ga74247b371dbb7594cc424f0f13e4b614"><td class="memTemplItemLeft" align="right" valign="top">move_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga74247b371dbb7594cc424f0f13e4b614">ranges::move</a> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="memdesc:ga74247b371dbb7594cc424f0f13e4b614"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga74247b371dbb7594cc424f0f13e4b614">More...</a><br /></td></tr>
<tr class="separator:ga74247b371dbb7594cc424f0f13e4b614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae774997d392e48e40b1e9f03d0660aa0"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O &gt; </td></tr>
<tr class="memitem:gae774997d392e48e40b1e9f03d0660aa0"><td class="memTemplItemLeft" align="right" valign="top">move_backward_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae774997d392e48e40b1e9f03d0660aa0">ranges::move_backward</a> (I first, S end_, O out)</td></tr>
<tr class="memdesc:gae774997d392e48e40b1e9f03d0660aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>move_backward</code>  <a href="group__group-algorithms.html#gae774997d392e48e40b1e9f03d0660aa0">More...</a><br /></td></tr>
<tr class="separator:gae774997d392e48e40b1e9f03d0660aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8084287106366f33e76614516ff00de3"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O &gt; </td></tr>
<tr class="memitem:ga8084287106366f33e76614516ff00de3"><td class="memTemplItemLeft" align="right" valign="top">move_backward_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8084287106366f33e76614516ff00de3">ranges::move_backward</a> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="memdesc:ga8084287106366f33e76614516ff00de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga8084287106366f33e76614516ff00de3">More...</a><br /></td></tr>
<tr class="separator:ga8084287106366f33e76614516ff00de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbad66b96d048b2dbc113f4d4d8871c7"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gabbad66b96d048b2dbc113f4d4d8871c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gabbad66b96d048b2dbc113f4d4d8871c7">ranges::next_permutation</a> (I first, S end_, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gabbad66b96d048b2dbc113f4d4d8871c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>next_permutation</code>  <a href="group__group-algorithms.html#gabbad66b96d048b2dbc113f4d4d8871c7">More...</a><br /></td></tr>
<tr class="separator:gabbad66b96d048b2dbc113f4d4d8871c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65344ec6be87cfbd56a501a6504213c6"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga65344ec6be87cfbd56a501a6504213c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga65344ec6be87cfbd56a501a6504213c6">ranges::next_permutation</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga65344ec6be87cfbd56a501a6504213c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga65344ec6be87cfbd56a501a6504213c6">More...</a><br /></td></tr>
<tr class="separator:ga65344ec6be87cfbd56a501a6504213c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d57af7919545020540efa343e2c331"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gac9d57af7919545020540efa343e2c331"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac9d57af7919545020540efa343e2c331">ranges::none_of</a> (I first, S last, F pred, P proj=P{})</td></tr>
<tr class="memdesc:gac9d57af7919545020540efa343e2c331"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>none_of</code>  <a href="group__group-algorithms.html#gac9d57af7919545020540efa343e2c331">More...</a><br /></td></tr>
<tr class="separator:gac9d57af7919545020540efa343e2c331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82de9da4afa96d2cd8d116f3ab6046ce"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga82de9da4afa96d2cd8d116f3ab6046ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga82de9da4afa96d2cd8d116f3ab6046ce">ranges::none_of</a> (Rng &amp;&amp;rng, F pred, P proj=P{})</td></tr>
<tr class="memdesc:ga82de9da4afa96d2cd8d116f3ab6046ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga82de9da4afa96d2cd8d116f3ab6046ce">More...</a><br /></td></tr>
<tr class="separator:ga82de9da4afa96d2cd8d116f3ab6046ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf32fdbad08e6e163dffef87374d8e5"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga1bf32fdbad08e6e163dffef87374d8e5"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1bf32fdbad08e6e163dffef87374d8e5">ranges::nth_element</a> (I first, I nth, S end_, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga1bf32fdbad08e6e163dffef87374d8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>nth_element</code>  <a href="group__group-algorithms.html#ga1bf32fdbad08e6e163dffef87374d8e5">More...</a><br /></td></tr>
<tr class="separator:ga1bf32fdbad08e6e163dffef87374d8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga493c30e7b6420ba5756207ef72e041e2"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga493c30e7b6420ba5756207ef72e041e2"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga493c30e7b6420ba5756207ef72e041e2">ranges::nth_element</a> (Rng &amp;&amp;rng, iterator_t&lt; Rng &gt; nth, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga493c30e7b6420ba5756207ef72e041e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga493c30e7b6420ba5756207ef72e041e2">More...</a><br /></td></tr>
<tr class="separator:ga493c30e7b6420ba5756207ef72e041e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa363038c0a0b57f21b453f58d1266f4e"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaa363038c0a0b57f21b453f58d1266f4e"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa363038c0a0b57f21b453f58d1266f4e">ranges::partial_sort</a> (I first, I middle, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gaa363038c0a0b57f21b453f58d1266f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partial_sort</code>  <a href="group__group-algorithms.html#gaa363038c0a0b57f21b453f58d1266f4e">More...</a><br /></td></tr>
<tr class="separator:gaa363038c0a0b57f21b453f58d1266f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2db73e0d2a523b1bfe4b7ce3f25c7dcc"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga2db73e0d2a523b1bfe4b7ce3f25c7dcc"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga2db73e0d2a523b1bfe4b7ce3f25c7dcc">ranges::partial_sort</a> (Rng &amp;&amp;rng, iterator_t&lt; Rng &gt; middle, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga2db73e0d2a523b1bfe4b7ce3f25c7dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga2db73e0d2a523b1bfe4b7ce3f25c7dcc">More...</a><br /></td></tr>
<tr class="separator:ga2db73e0d2a523b1bfe4b7ce3f25c7dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9cce103eb42a712a58c939d57a34d18"><td class="memTemplParams" colspan="2">template&lt;typename I , typename SI , typename O , typename SO , typename C  = less, typename PI  = identity, typename PO  = identity&gt; </td></tr>
<tr class="memitem:gaa9cce103eb42a712a58c939d57a34d18"><td class="memTemplItemLeft" align="right" valign="top">O&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa9cce103eb42a712a58c939d57a34d18">ranges::partial_sort_copy</a> (I first, SI last, O out_begin, SO out_end, C pred=C{}, PI in_proj=PI{}, PO out_proj=PO{})</td></tr>
<tr class="memdesc:gaa9cce103eb42a712a58c939d57a34d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partial_sort_copy</code>  <a href="group__group-algorithms.html#gaa9cce103eb42a712a58c939d57a34d18">More...</a><br /></td></tr>
<tr class="separator:gaa9cce103eb42a712a58c939d57a34d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc26b2da998f1c2610be46785d691965"><td class="memTemplParams" colspan="2">template&lt;typename InRng , typename OutRng , typename C  = less, typename PI  = identity, typename PO  = identity&gt; </td></tr>
<tr class="memitem:gadc26b2da998f1c2610be46785d691965"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; OutRng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gadc26b2da998f1c2610be46785d691965">ranges::partial_sort_copy</a> (InRng &amp;&amp;in_rng, OutRng &amp;&amp;out_rng, C pred=C{}, PI in_proj=PI{}, PO out_proj=PO{})</td></tr>
<tr class="memdesc:gadc26b2da998f1c2610be46785d691965"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gadc26b2da998f1c2610be46785d691965">More...</a><br /></td></tr>
<tr class="separator:gadc26b2da998f1c2610be46785d691965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97f1ddf8cf137833ab7e0c9f1d03b2d8"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga97f1ddf8cf137833ab7e0c9f1d03b2d8"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga97f1ddf8cf137833ab7e0c9f1d03b2d8">ranges::partition</a> (I first, S last, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga97f1ddf8cf137833ab7e0c9f1d03b2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partition</code>  <a href="group__group-algorithms.html#ga97f1ddf8cf137833ab7e0c9f1d03b2d8">More...</a><br /></td></tr>
<tr class="separator:ga97f1ddf8cf137833ab7e0c9f1d03b2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987745c576bda2edea769132ca28f7f8"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga987745c576bda2edea769132ca28f7f8"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga987745c576bda2edea769132ca28f7f8">ranges::partition</a> (Rng &amp;&amp;rng, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga987745c576bda2edea769132ca28f7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga987745c576bda2edea769132ca28f7f8">More...</a><br /></td></tr>
<tr class="separator:ga987745c576bda2edea769132ca28f7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ada17895d1ee5bd9e5630f8dcae37df"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O0 , typename O1 , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga9ada17895d1ee5bd9e5630f8dcae37df"><td class="memTemplItemLeft" align="right" valign="top">partition_copy_result&lt; I, O0, O1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9ada17895d1ee5bd9e5630f8dcae37df">ranges::partition_copy</a> (I first, S last, O0 o0, O1 o1, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga9ada17895d1ee5bd9e5630f8dcae37df"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partition_copy</code>  <a href="group__group-algorithms.html#ga9ada17895d1ee5bd9e5630f8dcae37df">More...</a><br /></td></tr>
<tr class="separator:ga9ada17895d1ee5bd9e5630f8dcae37df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f0e361fe494bb4e89b6226633f9a873"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O0 , typename O1 , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga4f0e361fe494bb4e89b6226633f9a873"><td class="memTemplItemLeft" align="right" valign="top">partition_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O0, O1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga4f0e361fe494bb4e89b6226633f9a873">ranges::partition_copy</a> (Rng &amp;&amp;rng, O0 o0, O1 o1, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga4f0e361fe494bb4e89b6226633f9a873"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga4f0e361fe494bb4e89b6226633f9a873">More...</a><br /></td></tr>
<tr class="separator:ga4f0e361fe494bb4e89b6226633f9a873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46862e538efe454cea0319c4eb4a0971"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga46862e538efe454cea0319c4eb4a0971"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga46862e538efe454cea0319c4eb4a0971">ranges::partition_point</a> (I first, S last, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga46862e538efe454cea0319c4eb4a0971"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partition_point</code>  <a href="group__group-algorithms.html#ga46862e538efe454cea0319c4eb4a0971">More...</a><br /></td></tr>
<tr class="separator:ga46862e538efe454cea0319c4eb4a0971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac459d68549e5035017526ea753324127"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:gac459d68549e5035017526ea753324127"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac459d68549e5035017526ea753324127">ranges::partition_point</a> (Rng &amp;&amp;rng, C pred, P proj=P{})</td></tr>
<tr class="memdesc:gac459d68549e5035017526ea753324127"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gac459d68549e5035017526ea753324127">More...</a><br /></td></tr>
<tr class="separator:gac459d68549e5035017526ea753324127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad683654880ba140d1b7f4abdf27c8f50"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gad683654880ba140d1b7f4abdf27c8f50"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad683654880ba140d1b7f4abdf27c8f50">ranges::pop_heap</a> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gad683654880ba140d1b7f4abdf27c8f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>pop_heap</code>  <a href="group__group-algorithms.html#gad683654880ba140d1b7f4abdf27c8f50">More...</a><br /></td></tr>
<tr class="separator:gad683654880ba140d1b7f4abdf27c8f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfaf935b1bf578fd762c9122f3a2d477"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gacfaf935b1bf578fd762c9122f3a2d477"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gacfaf935b1bf578fd762c9122f3a2d477">ranges::pop_heap</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gacfaf935b1bf578fd762c9122f3a2d477"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gacfaf935b1bf578fd762c9122f3a2d477">More...</a><br /></td></tr>
<tr class="separator:gacfaf935b1bf578fd762c9122f3a2d477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35e4305e5a7028c2795088228483a4fa"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga35e4305e5a7028c2795088228483a4fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga35e4305e5a7028c2795088228483a4fa">ranges::prev_permutation</a> (I first, S end_, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga35e4305e5a7028c2795088228483a4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>prev_permutation</code>  <a href="group__group-algorithms.html#ga35e4305e5a7028c2795088228483a4fa">More...</a><br /></td></tr>
<tr class="separator:ga35e4305e5a7028c2795088228483a4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacec90d3d5c7083285553c6de395acc92"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gacec90d3d5c7083285553c6de395acc92"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gacec90d3d5c7083285553c6de395acc92">ranges::prev_permutation</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gacec90d3d5c7083285553c6de395acc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gacec90d3d5c7083285553c6de395acc92">More...</a><br /></td></tr>
<tr class="separator:gacec90d3d5c7083285553c6de395acc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga704ea334d99e4a5af0bf81988f771d67"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga704ea334d99e4a5af0bf81988f771d67"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga704ea334d99e4a5af0bf81988f771d67">ranges::push_heap</a> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga704ea334d99e4a5af0bf81988f771d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>push_heap</code>  <a href="group__group-algorithms.html#ga704ea334d99e4a5af0bf81988f771d67">More...</a><br /></td></tr>
<tr class="separator:ga704ea334d99e4a5af0bf81988f771d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb3991e5dbdd90ba10a8143832d31333"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaeb3991e5dbdd90ba10a8143832d31333"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaeb3991e5dbdd90ba10a8143832d31333">ranges::push_heap</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gaeb3991e5dbdd90ba10a8143832d31333"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gaeb3991e5dbdd90ba10a8143832d31333">More...</a><br /></td></tr>
<tr class="separator:gaeb3991e5dbdd90ba10a8143832d31333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89961c91281e7d6826e37c890cf34e4"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:gad89961c91281e7d6826e37c890cf34e4"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad89961c91281e7d6826e37c890cf34e4">ranges::remove</a> (I first, S last, T const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:gad89961c91281e7d6826e37c890cf34e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>remove</code>  <a href="group__group-algorithms.html#gad89961c91281e7d6826e37c890cf34e4">More...</a><br /></td></tr>
<tr class="separator:gad89961c91281e7d6826e37c890cf34e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84ea278263269d9f6d0e62fc3188c340"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga84ea278263269d9f6d0e62fc3188c340"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga84ea278263269d9f6d0e62fc3188c340">ranges::remove</a> (Rng &amp;&amp;rng, T const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:ga84ea278263269d9f6d0e62fc3188c340"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga84ea278263269d9f6d0e62fc3188c340">More...</a><br /></td></tr>
<tr class="separator:ga84ea278263269d9f6d0e62fc3188c340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9be4f0ea2feb61677a0054563c08aba"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:gae9be4f0ea2feb61677a0054563c08aba"><td class="memTemplItemLeft" align="right" valign="top">remove_copy_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae9be4f0ea2feb61677a0054563c08aba">ranges::remove_copy</a> (I first, S last, O out, T const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:gae9be4f0ea2feb61677a0054563c08aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>remove_copy</code>  <a href="group__group-algorithms.html#gae9be4f0ea2feb61677a0054563c08aba">More...</a><br /></td></tr>
<tr class="separator:gae9be4f0ea2feb61677a0054563c08aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga519f6c415fe173faf79c3759e0160d61"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga519f6c415fe173faf79c3759e0160d61"><td class="memTemplItemLeft" align="right" valign="top">remove_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga519f6c415fe173faf79c3759e0160d61">ranges::remove_copy</a> (Rng &amp;&amp;rng, O out, T const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:ga519f6c415fe173faf79c3759e0160d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga519f6c415fe173faf79c3759e0160d61">More...</a><br /></td></tr>
<tr class="separator:ga519f6c415fe173faf79c3759e0160d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bb4a3be82501194dfabe02e9ea6733a"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga8bb4a3be82501194dfabe02e9ea6733a"><td class="memTemplItemLeft" align="right" valign="top">remove_copy_if_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8bb4a3be82501194dfabe02e9ea6733a">ranges::remove_copy_if</a> (I first, S last, O out, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga8bb4a3be82501194dfabe02e9ea6733a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>remove_copy_if</code>  <a href="group__group-algorithms.html#ga8bb4a3be82501194dfabe02e9ea6733a">More...</a><br /></td></tr>
<tr class="separator:ga8bb4a3be82501194dfabe02e9ea6733a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7565c31ed66deb9c075d04cfa1dec52e"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga7565c31ed66deb9c075d04cfa1dec52e"><td class="memTemplItemLeft" align="right" valign="top">remove_copy_if_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga7565c31ed66deb9c075d04cfa1dec52e">ranges::remove_copy_if</a> (Rng &amp;&amp;rng, O out, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga7565c31ed66deb9c075d04cfa1dec52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga7565c31ed66deb9c075d04cfa1dec52e">More...</a><br /></td></tr>
<tr class="separator:ga7565c31ed66deb9c075d04cfa1dec52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb87211288523ed6bfe2d12defe1b646"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:gafb87211288523ed6bfe2d12defe1b646"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafb87211288523ed6bfe2d12defe1b646">ranges::remove_if</a> (I first, S last, C pred, P proj=P{})</td></tr>
<tr class="memdesc:gafb87211288523ed6bfe2d12defe1b646"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>remove_if</code>  <a href="group__group-algorithms.html#gafb87211288523ed6bfe2d12defe1b646">More...</a><br /></td></tr>
<tr class="separator:gafb87211288523ed6bfe2d12defe1b646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5439d9af75d1c2709f3bc4a8eff20f21"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga5439d9af75d1c2709f3bc4a8eff20f21"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga5439d9af75d1c2709f3bc4a8eff20f21">ranges::remove_if</a> (Rng &amp;&amp;rng, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga5439d9af75d1c2709f3bc4a8eff20f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga5439d9af75d1c2709f3bc4a8eff20f21">More...</a><br /></td></tr>
<tr class="separator:ga5439d9af75d1c2709f3bc4a8eff20f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9f0ab4f61c4cc77141474a8b072e3b0"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename T1 , typename T2 , typename P  = identity&gt; </td></tr>
<tr class="memitem:gad9f0ab4f61c4cc77141474a8b072e3b0"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad9f0ab4f61c4cc77141474a8b072e3b0">ranges::replace</a> (I first, S last, T1 const &amp;old_value, T2 const &amp;new_value, P proj={})</td></tr>
<tr class="memdesc:gad9f0ab4f61c4cc77141474a8b072e3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace</code>  <a href="group__group-algorithms.html#gad9f0ab4f61c4cc77141474a8b072e3b0">More...</a><br /></td></tr>
<tr class="separator:gad9f0ab4f61c4cc77141474a8b072e3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a81c8dbd43c604acec346421deeef6"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename T1 , typename T2 , typename P  = identity&gt; </td></tr>
<tr class="memitem:gaf3a81c8dbd43c604acec346421deeef6"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaf3a81c8dbd43c604acec346421deeef6">ranges::replace</a> (Rng &amp;&amp;rng, T1 const &amp;old_value, T2 const &amp;new_value, P proj={})</td></tr>
<tr class="memdesc:gaf3a81c8dbd43c604acec346421deeef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gaf3a81c8dbd43c604acec346421deeef6">More...</a><br /></td></tr>
<tr class="separator:gaf3a81c8dbd43c604acec346421deeef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa356096a9c9c1a7c98e2681b78fce078"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O , typename T1 , typename T2 , typename P  = identity&gt; </td></tr>
<tr class="memitem:gaa356096a9c9c1a7c98e2681b78fce078"><td class="memTemplItemLeft" align="right" valign="top">replace_copy_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa356096a9c9c1a7c98e2681b78fce078">ranges::replace_copy</a> (I first, S last, O out, T1 const &amp;old_value, T2 const &amp;new_value, P proj={})</td></tr>
<tr class="memdesc:gaa356096a9c9c1a7c98e2681b78fce078"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace_copy</code>  <a href="group__group-algorithms.html#gaa356096a9c9c1a7c98e2681b78fce078">More...</a><br /></td></tr>
<tr class="separator:gaa356096a9c9c1a7c98e2681b78fce078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15cdc17bceab41545f4a53877f7479ef"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename T1 , typename T2 , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga15cdc17bceab41545f4a53877f7479ef"><td class="memTemplItemLeft" align="right" valign="top">replace_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga15cdc17bceab41545f4a53877f7479ef">ranges::replace_copy</a> (Rng &amp;&amp;rng, O out, T1 const &amp;old_value, T2 const &amp;new_value, P proj={})</td></tr>
<tr class="memdesc:ga15cdc17bceab41545f4a53877f7479ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga15cdc17bceab41545f4a53877f7479ef">More...</a><br /></td></tr>
<tr class="separator:ga15cdc17bceab41545f4a53877f7479ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c28401b7718815f571b0de3871f762a"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O , typename C , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga8c28401b7718815f571b0de3871f762a"><td class="memTemplItemLeft" align="right" valign="top">replace_copy_if_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8c28401b7718815f571b0de3871f762a">ranges::replace_copy_if</a> (I first, S last, O out, C pred, T const &amp;new_value, P proj={})</td></tr>
<tr class="memdesc:ga8c28401b7718815f571b0de3871f762a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace_copy_if</code>  <a href="group__group-algorithms.html#ga8c28401b7718815f571b0de3871f762a">More...</a><br /></td></tr>
<tr class="separator:ga8c28401b7718815f571b0de3871f762a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9b462cc8ce255c5a2e9ec19a05ec84"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename C , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga4d9b462cc8ce255c5a2e9ec19a05ec84"><td class="memTemplItemLeft" align="right" valign="top">replace_copy_if_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga4d9b462cc8ce255c5a2e9ec19a05ec84">ranges::replace_copy_if</a> (Rng &amp;&amp;rng, O out, C pred, T const &amp;new_value, P proj={})</td></tr>
<tr class="memdesc:ga4d9b462cc8ce255c5a2e9ec19a05ec84"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga4d9b462cc8ce255c5a2e9ec19a05ec84">More...</a><br /></td></tr>
<tr class="separator:ga4d9b462cc8ce255c5a2e9ec19a05ec84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacafb6d5fad860c920547555d5365e16"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:gaacafb6d5fad860c920547555d5365e16"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaacafb6d5fad860c920547555d5365e16">ranges::replace_if</a> (I first, S last, C pred, T const &amp;new_value, P proj=P{})</td></tr>
<tr class="memdesc:gaacafb6d5fad860c920547555d5365e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace_if</code>  <a href="group__group-algorithms.html#gaacafb6d5fad860c920547555d5365e16">More...</a><br /></td></tr>
<tr class="separator:gaacafb6d5fad860c920547555d5365e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga864292d2f285f303d3ca78f766bc70b6"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga864292d2f285f303d3ca78f766bc70b6"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga864292d2f285f303d3ca78f766bc70b6">ranges::replace_if</a> (Rng &amp;&amp;rng, C pred, T const &amp;new_value, P proj=P{})</td></tr>
<tr class="memdesc:ga864292d2f285f303d3ca78f766bc70b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga864292d2f285f303d3ca78f766bc70b6">More...</a><br /></td></tr>
<tr class="separator:ga864292d2f285f303d3ca78f766bc70b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239c5b656b7d4eb1728146c27c79701a"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:ga239c5b656b7d4eb1728146c27c79701a"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga239c5b656b7d4eb1728146c27c79701a">ranges::reverse</a> (I first, S end_)</td></tr>
<tr class="memdesc:ga239c5b656b7d4eb1728146c27c79701a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>reverse</code>  <a href="group__group-algorithms.html#ga239c5b656b7d4eb1728146c27c79701a">More...</a><br /></td></tr>
<tr class="separator:ga239c5b656b7d4eb1728146c27c79701a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9376808c93a60e83f6e012405a780dc"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename I  = iterator_t&lt;Rng&gt;&gt; </td></tr>
<tr class="memitem:gab9376808c93a60e83f6e012405a780dc"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab9376808c93a60e83f6e012405a780dc">ranges::reverse</a> (Rng &amp;&amp;rng)</td></tr>
<tr class="memdesc:gab9376808c93a60e83f6e012405a780dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gab9376808c93a60e83f6e012405a780dc">More...</a><br /></td></tr>
<tr class="separator:gab9376808c93a60e83f6e012405a780dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36294489bc4284839d44e5b994c8e668"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O &gt; </td></tr>
<tr class="memitem:ga36294489bc4284839d44e5b994c8e668"><td class="memTemplItemLeft" align="right" valign="top">reverse_copy_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga36294489bc4284839d44e5b994c8e668">ranges::reverse_copy</a> (I first, S end_, O out)</td></tr>
<tr class="memdesc:ga36294489bc4284839d44e5b994c8e668"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>reverse_copy</code>  <a href="group__group-algorithms.html#ga36294489bc4284839d44e5b994c8e668">More...</a><br /></td></tr>
<tr class="separator:ga36294489bc4284839d44e5b994c8e668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad516cf254a226899487ad08609f81128"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O &gt; </td></tr>
<tr class="memitem:gad516cf254a226899487ad08609f81128"><td class="memTemplItemLeft" align="right" valign="top">reverse_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad516cf254a226899487ad08609f81128">ranges::reverse_copy</a> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="memdesc:gad516cf254a226899487ad08609f81128"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gad516cf254a226899487ad08609f81128">More...</a><br /></td></tr>
<tr class="separator:gad516cf254a226899487ad08609f81128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33a5ef3705f30edd28453a9999cd576d"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:ga33a5ef3705f30edd28453a9999cd576d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga33a5ef3705f30edd28453a9999cd576d">ranges::rotate</a> (I first, I middle, S last)</td></tr>
<tr class="memdesc:ga33a5ef3705f30edd28453a9999cd576d"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>rotate</code>  <a href="group__group-algorithms.html#ga33a5ef3705f30edd28453a9999cd576d">More...</a><br /></td></tr>
<tr class="separator:ga33a5ef3705f30edd28453a9999cd576d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae12d6438e495d01fb95843e6b6f8c35b"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename I  = iterator_t&lt;Rng&gt;&gt; </td></tr>
<tr class="memitem:gae12d6438e495d01fb95843e6b6f8c35b"><td class="memTemplItemLeft" align="right" valign="top">borrowed_subrange_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae12d6438e495d01fb95843e6b6f8c35b">ranges::rotate</a> (Rng &amp;&amp;rng, I middle)</td></tr>
<tr class="memdesc:gae12d6438e495d01fb95843e6b6f8c35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gae12d6438e495d01fb95843e6b6f8c35b">More...</a><br /></td></tr>
<tr class="separator:gae12d6438e495d01fb95843e6b6f8c35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab66377c07c8ec5bfe40e178161a05a88"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O , typename P  = identity&gt; </td></tr>
<tr class="memitem:gab66377c07c8ec5bfe40e178161a05a88"><td class="memTemplItemLeft" align="right" valign="top">rotate_copy_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab66377c07c8ec5bfe40e178161a05a88">ranges::rotate_copy</a> (I first, I middle, S last, O out)</td></tr>
<tr class="memdesc:gab66377c07c8ec5bfe40e178161a05a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>rotate_copy</code>  <a href="group__group-algorithms.html#gab66377c07c8ec5bfe40e178161a05a88">More...</a><br /></td></tr>
<tr class="separator:gab66377c07c8ec5bfe40e178161a05a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac033357be8dd033636408498e7ee5f2f"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename P  = identity&gt; </td></tr>
<tr class="memitem:gac033357be8dd033636408498e7ee5f2f"><td class="memTemplItemLeft" align="right" valign="top">rotate_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac033357be8dd033636408498e7ee5f2f">ranges::rotate_copy</a> (Rng &amp;&amp;rng, iterator_t&lt; Rng &gt; middle, O out)</td></tr>
<tr class="memdesc:gac033357be8dd033636408498e7ee5f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gac033357be8dd033636408498e7ee5f2f">More...</a><br /></td></tr>
<tr class="separator:gac033357be8dd033636408498e7ee5f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8d67e6ed0aed443b194355578612321"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O , typename Gen  = detail::default_random_engine &amp;&gt; </td></tr>
<tr class="memitem:gae8d67e6ed0aed443b194355578612321"><td class="memTemplItemLeft" align="right" valign="top">sample_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae8d67e6ed0aed443b194355578612321">ranges::sample</a> (I first, S last, O out, iter_difference_t&lt; O &gt; const n, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="memdesc:gae8d67e6ed0aed443b194355578612321"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>sample</code>  <a href="group__group-algorithms.html#gae8d67e6ed0aed443b194355578612321">More...</a><br /></td></tr>
<tr class="separator:gae8d67e6ed0aed443b194355578612321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa000641779e549556cc32c94214f690"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename ORng , typename Gen  = detail::default_random_engine &amp;&gt; </td></tr>
<tr class="memitem:gaaa000641779e549556cc32c94214f690"><td class="memTemplItemLeft" align="right" valign="top">sample_result&lt; I, borrowed_iterator_t&lt; ORng &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaaa000641779e549556cc32c94214f690">ranges::sample</a> (I first, S last, ORng &amp;&amp;out, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="memdesc:gaaa000641779e549556cc32c94214f690"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gaaa000641779e549556cc32c94214f690">More...</a><br /></td></tr>
<tr class="separator:gaaa000641779e549556cc32c94214f690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31a99d76c57f2468f135e056dd4817a7"><td class="memTemplParams" colspan="2">template&lt;typename IRng , typename ORng , typename Gen  = detail::default_random_engine &amp;&gt; </td></tr>
<tr class="memitem:ga31a99d76c57f2468f135e056dd4817a7"><td class="memTemplItemLeft" align="right" valign="top">sample_result&lt; borrowed_iterator_t&lt; IRng &gt;, borrowed_iterator_t&lt; ORng &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga31a99d76c57f2468f135e056dd4817a7">ranges::sample</a> (IRng &amp;&amp;rng, ORng &amp;&amp;out, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="memdesc:ga31a99d76c57f2468f135e056dd4817a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga31a99d76c57f2468f135e056dd4817a7">More...</a><br /></td></tr>
<tr class="separator:ga31a99d76c57f2468f135e056dd4817a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f3464d4bf77e969e86742fb67e40cce"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename Gen  = detail::default_random_engine &amp;&gt; </td></tr>
<tr class="memitem:ga8f3464d4bf77e969e86742fb67e40cce"><td class="memTemplItemLeft" align="right" valign="top">sample_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8f3464d4bf77e969e86742fb67e40cce">ranges::sample</a> (Rng &amp;&amp;rng, O out, iter_difference_t&lt; O &gt; const n, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="memdesc:ga8f3464d4bf77e969e86742fb67e40cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga8f3464d4bf77e969e86742fb67e40cce">More...</a><br /></td></tr>
<tr class="separator:ga8f3464d4bf77e969e86742fb67e40cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2619678aebd4a3f84fc5e82f0e7adc9c"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga2619678aebd4a3f84fc5e82f0e7adc9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga2619678aebd4a3f84fc5e82f0e7adc9c">ranges::search</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga2619678aebd4a3f84fc5e82f0e7adc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>search</code>  <a href="group__group-algorithms.html#ga2619678aebd4a3f84fc5e82f0e7adc9c">More...</a><br /></td></tr>
<tr class="separator:ga2619678aebd4a3f84fc5e82f0e7adc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084b0595139e0d6199f9caff6ae58ba0"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga084b0595139e0d6199f9caff6ae58ba0"><td class="memTemplItemLeft" align="right" valign="top">borrowed_subrange_t&lt; <a class="el" href="class_rng1.html">Rng1</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga084b0595139e0d6199f9caff6ae58ba0">ranges::search</a> (<a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;rng2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga084b0595139e0d6199f9caff6ae58ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga084b0595139e0d6199f9caff6ae58ba0">More...</a><br /></td></tr>
<tr class="separator:ga084b0595139e0d6199f9caff6ae58ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee041e8740d83af1fa6a316e3d17a67e"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename V , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaee041e8740d83af1fa6a316e3d17a67e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaee041e8740d83af1fa6a316e3d17a67e">ranges::search_n</a> (I first, S last, iter_difference_t&lt; I &gt; cnt, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gaee041e8740d83af1fa6a316e3d17a67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>search_n</code>  <a href="group__group-algorithms.html#gaee041e8740d83af1fa6a316e3d17a67e">More...</a><br /></td></tr>
<tr class="separator:gaee041e8740d83af1fa6a316e3d17a67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2556ca4206528d72c5043e1c88ec48bc"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga2556ca4206528d72c5043e1c88ec48bc"><td class="memTemplItemLeft" align="right" valign="top">borrowed_subrange_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga2556ca4206528d72c5043e1c88ec48bc">ranges::search_n</a> (Rng &amp;&amp;rng, iter_difference_t&lt; iterator_t&lt; Rng &gt;&gt; cnt, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga2556ca4206528d72c5043e1c88ec48bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga2556ca4206528d72c5043e1c88ec48bc">More...</a><br /></td></tr>
<tr class="separator:ga2556ca4206528d72c5043e1c88ec48bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8114322fbf39a5beb3c7d34baad0f2c3"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga8114322fbf39a5beb3c7d34baad0f2c3"><td class="memTemplItemLeft" align="right" valign="top">set_difference_result&lt; I1, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8114322fbf39a5beb3c7d34baad0f2c3">ranges::set_difference</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga8114322fbf39a5beb3c7d34baad0f2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>set_difference</code>  <a href="group__group-algorithms.html#ga8114322fbf39a5beb3c7d34baad0f2c3">More...</a><br /></td></tr>
<tr class="separator:ga8114322fbf39a5beb3c7d34baad0f2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59edbf9d54ccf35065cf4accea2fb199"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga59edbf9d54ccf35065cf4accea2fb199"><td class="memTemplItemLeft" align="right" valign="top">set_difference_result&lt; borrowed_iterator_t&lt; <a class="el" href="class_rng1.html">Rng1</a> &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga59edbf9d54ccf35065cf4accea2fb199">ranges::set_difference</a> (<a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;rng2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga59edbf9d54ccf35065cf4accea2fb199"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga59edbf9d54ccf35065cf4accea2fb199">More...</a><br /></td></tr>
<tr class="separator:ga59edbf9d54ccf35065cf4accea2fb199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf0526cb508732ba6f86873ce5a200d4"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gaaf0526cb508732ba6f86873ce5a200d4"><td class="memTemplItemLeft" align="right" valign="top">O&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaaf0526cb508732ba6f86873ce5a200d4">ranges::set_intersection</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gaaf0526cb508732ba6f86873ce5a200d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>set_intersection</code>  <a href="group__group-algorithms.html#gaaf0526cb508732ba6f86873ce5a200d4">More...</a><br /></td></tr>
<tr class="separator:gaaf0526cb508732ba6f86873ce5a200d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc54963b11acb1941decff1d294a55"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gaf5dc54963b11acb1941decff1d294a55"><td class="memTemplItemLeft" align="right" valign="top">O&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaf5dc54963b11acb1941decff1d294a55">ranges::set_intersection</a> (<a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;rng2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gaf5dc54963b11acb1941decff1d294a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gaf5dc54963b11acb1941decff1d294a55">More...</a><br /></td></tr>
<tr class="separator:gaf5dc54963b11acb1941decff1d294a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb5448383dd335b49a140b6d71237d3"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gaedb5448383dd335b49a140b6d71237d3"><td class="memTemplItemLeft" align="right" valign="top">set_symmetric_difference_result&lt; I1, I2, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaedb5448383dd335b49a140b6d71237d3">ranges::set_symmetric_difference</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gaedb5448383dd335b49a140b6d71237d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>set_symmetric_difference</code>  <a href="group__group-algorithms.html#gaedb5448383dd335b49a140b6d71237d3">More...</a><br /></td></tr>
<tr class="separator:gaedb5448383dd335b49a140b6d71237d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9453fef4931e8441d363cbca9784d038"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga9453fef4931e8441d363cbca9784d038"><td class="memTemplItemLeft" align="right" valign="top">set_symmetric_difference_result&lt; borrowed_iterator_t&lt; <a class="el" href="class_rng1.html">Rng1</a> &gt;, borrowed_iterator_t&lt; <a class="el" href="class_rng2.html">Rng2</a> &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9453fef4931e8441d363cbca9784d038">ranges::set_symmetric_difference</a> (<a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;rng2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga9453fef4931e8441d363cbca9784d038"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga9453fef4931e8441d363cbca9784d038">More...</a><br /></td></tr>
<tr class="separator:ga9453fef4931e8441d363cbca9784d038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a949af1cd40bea844eec95349af42bc"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga9a949af1cd40bea844eec95349af42bc"><td class="memTemplItemLeft" align="right" valign="top">set_union_result&lt; I1, I2, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9a949af1cd40bea844eec95349af42bc">ranges::set_union</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga9a949af1cd40bea844eec95349af42bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>set_union</code>  <a href="group__group-algorithms.html#ga9a949af1cd40bea844eec95349af42bc">More...</a><br /></td></tr>
<tr class="separator:ga9a949af1cd40bea844eec95349af42bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcec48c80d2a0ec158e31112086fae4c"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gabcec48c80d2a0ec158e31112086fae4c"><td class="memTemplItemLeft" align="right" valign="top">set_union_result&lt; borrowed_iterator_t&lt; <a class="el" href="class_rng1.html">Rng1</a> &gt;, borrowed_iterator_t&lt; <a class="el" href="class_rng2.html">Rng2</a> &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gabcec48c80d2a0ec158e31112086fae4c">ranges::set_union</a> (<a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;rng2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gabcec48c80d2a0ec158e31112086fae4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gabcec48c80d2a0ec158e31112086fae4c">More...</a><br /></td></tr>
<tr class="separator:gabcec48c80d2a0ec158e31112086fae4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64a6b65cb4132a8a66c31fbe45ff3184"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename Gen  = detail::default_random_engine &amp;&gt; </td></tr>
<tr class="memitem:ga64a6b65cb4132a8a66c31fbe45ff3184"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga64a6b65cb4132a8a66c31fbe45ff3184">ranges::shuffle</a> (I const first, S const last, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="memdesc:ga64a6b65cb4132a8a66c31fbe45ff3184"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>shuffle</code>  <a href="group__group-algorithms.html#ga64a6b65cb4132a8a66c31fbe45ff3184">More...</a><br /></td></tr>
<tr class="separator:ga64a6b65cb4132a8a66c31fbe45ff3184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46f7189cf5e33ed9a4cc65ef9e1bcf57"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename Gen  = detail::default_random_engine &amp;&gt; </td></tr>
<tr class="memitem:ga46f7189cf5e33ed9a4cc65ef9e1bcf57"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga46f7189cf5e33ed9a4cc65ef9e1bcf57">ranges::shuffle</a> (Rng &amp;&amp;rng, Gen &amp;&amp;rand=detail::get_random_engine())</td></tr>
<tr class="memdesc:ga46f7189cf5e33ed9a4cc65ef9e1bcf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga46f7189cf5e33ed9a4cc65ef9e1bcf57">More...</a><br /></td></tr>
<tr class="separator:ga46f7189cf5e33ed9a4cc65ef9e1bcf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga008113a56544984350e5a0ab428acccd"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga008113a56544984350e5a0ab428acccd"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga008113a56544984350e5a0ab428acccd">ranges::sort</a> (I first, S end_, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga008113a56544984350e5a0ab428acccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>sort</code>  <a href="group__group-algorithms.html#ga008113a56544984350e5a0ab428acccd">More...</a><br /></td></tr>
<tr class="separator:ga008113a56544984350e5a0ab428acccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaebdad7bb17dd9fe0d23afe94eb9231"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaaaebdad7bb17dd9fe0d23afe94eb9231"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaaaebdad7bb17dd9fe0d23afe94eb9231">ranges::sort</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gaaaebdad7bb17dd9fe0d23afe94eb9231"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gaaaebdad7bb17dd9fe0d23afe94eb9231">More...</a><br /></td></tr>
<tr class="separator:gaaaebdad7bb17dd9fe0d23afe94eb9231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3b2b50224f18da2d4c5601c388b86ac"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gae3b2b50224f18da2d4c5601c388b86ac"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae3b2b50224f18da2d4c5601c388b86ac">ranges::sort_heap</a> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="separator:gae3b2b50224f18da2d4c5601c388b86ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a5e8ae2a411dd9931c5af40827c53d3"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga0a5e8ae2a411dd9931c5af40827c53d3"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0a5e8ae2a411dd9931c5af40827c53d3">ranges::sort_heap</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="separator:ga0a5e8ae2a411dd9931c5af40827c53d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56415c7caf1b400d608f758b08d9036e"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga56415c7caf1b400d608f758b08d9036e"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga56415c7caf1b400d608f758b08d9036e">ranges::stable_partition</a> (I first, S last, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga56415c7caf1b400d608f758b08d9036e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>stable_partition</code>  <a href="group__group-algorithms.html#ga56415c7caf1b400d608f758b08d9036e">More...</a><br /></td></tr>
<tr class="separator:ga56415c7caf1b400d608f758b08d9036e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga290c9e472e8224f67c0a24250c63536f"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga290c9e472e8224f67c0a24250c63536f"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga290c9e472e8224f67c0a24250c63536f">ranges::stable_partition</a> (Rng &amp;&amp;rng, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga290c9e472e8224f67c0a24250c63536f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga290c9e472e8224f67c0a24250c63536f">More...</a><br /></td></tr>
<tr class="separator:ga290c9e472e8224f67c0a24250c63536f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga744aa2d7beb5a12115be0a7a1db6e86d"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga744aa2d7beb5a12115be0a7a1db6e86d"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga744aa2d7beb5a12115be0a7a1db6e86d">ranges::stable_sort</a> (I first, S end_, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga744aa2d7beb5a12115be0a7a1db6e86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>stable_sort</code>  <a href="group__group-algorithms.html#ga744aa2d7beb5a12115be0a7a1db6e86d">More...</a><br /></td></tr>
<tr class="separator:ga744aa2d7beb5a12115be0a7a1db6e86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbb4bbc0d34818b1601dec3812147d2e"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gacbb4bbc0d34818b1601dec3812147d2e"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gacbb4bbc0d34818b1601dec3812147d2e">ranges::stable_sort</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gacbb4bbc0d34818b1601dec3812147d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gacbb4bbc0d34818b1601dec3812147d2e">More...</a><br /></td></tr>
<tr class="separator:gacbb4bbc0d34818b1601dec3812147d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aa76e38d88b172fc05bb4a556efa7ed"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename Comp  = equal_to, typename Proj1  = identity, typename Proj2  = identity&gt; </td></tr>
<tr class="memitem:ga0aa76e38d88b172fc05bb4a556efa7ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0aa76e38d88b172fc05bb4a556efa7ed">ranges::starts_with</a> (I1 first1, S1 last1, I2 first2, S2 last2, Comp comp={}, Proj1 proj1={}, Proj2 proj2={})</td></tr>
<tr class="memdesc:ga0aa76e38d88b172fc05bb4a556efa7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>starts_with</code>  <a href="group__group-algorithms.html#ga0aa76e38d88b172fc05bb4a556efa7ed">More...</a><br /></td></tr>
<tr class="separator:ga0aa76e38d88b172fc05bb4a556efa7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67981af4513f2c9962b5223e4f7115bf"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 , typename Comp  = equal_to, typename Proj1  = identity, typename Proj2  = identity&gt; </td></tr>
<tr class="memitem:ga67981af4513f2c9962b5223e4f7115bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga67981af4513f2c9962b5223e4f7115bf">ranges::starts_with</a> (R1 &amp;&amp;r1, R2 &amp;&amp;r2, Comp comp={}, Proj1 proj1={}, Proj2 proj2={})</td></tr>
<tr class="memdesc:ga67981af4513f2c9962b5223e4f7115bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga67981af4513f2c9962b5223e4f7115bf">More...</a><br /></td></tr>
<tr class="separator:ga67981af4513f2c9962b5223e4f7115bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9ae7d86273d4ae63fb1f7c7c21fa334"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 &gt; </td></tr>
<tr class="memitem:gaf9ae7d86273d4ae63fb1f7c7c21fa334"><td class="memTemplItemLeft" align="right" valign="top">swap_ranges_result&lt; I1, I2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaf9ae7d86273d4ae63fb1f7c7c21fa334">ranges::swap_ranges</a> (I1 begin1, S1 end1, I2 begin2)</td></tr>
<tr class="memdesc:gaf9ae7d86273d4ae63fb1f7c7c21fa334"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>swap_ranges</code>  <a href="group__group-algorithms.html#gaf9ae7d86273d4ae63fb1f7c7c21fa334">More...</a><br /></td></tr>
<tr class="separator:gaf9ae7d86273d4ae63fb1f7c7c21fa334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a583d3643b3f2057a280f54308f41e9"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga8a583d3643b3f2057a280f54308f41e9"><td class="memTemplItemLeft" align="right" valign="top">swap_ranges_result&lt; I1, I2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8a583d3643b3f2057a280f54308f41e9">ranges::swap_ranges</a> (I1 begin1, S1 end1, I2 begin2, S2 end2)</td></tr>
<tr class="memdesc:ga8a583d3643b3f2057a280f54308f41e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga8a583d3643b3f2057a280f54308f41e9">More...</a><br /></td></tr>
<tr class="separator:ga8a583d3643b3f2057a280f54308f41e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e4f36935f86807f07c653f0c10319c"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename I2_ &gt; </td></tr>
<tr class="memitem:gac7e4f36935f86807f07c653f0c10319c"><td class="memTemplItemLeft" align="right" valign="top">swap_ranges_result&lt; iterator_t&lt; <a class="el" href="class_rng1.html">Rng1</a> &gt;, uncvref_t&lt; I2_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac7e4f36935f86807f07c653f0c10319c">ranges::swap_ranges</a> (<a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, I2_ &amp;&amp;begin2)</td></tr>
<tr class="separator:gac7e4f36935f86807f07c653f0c10319c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa48d0e7d2e6042cee0d250875e513d3"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 &gt; </td></tr>
<tr class="memitem:gafa48d0e7d2e6042cee0d250875e513d3"><td class="memTemplItemLeft" align="right" valign="top">swap_ranges_result&lt; borrowed_iterator_t&lt; <a class="el" href="class_rng1.html">Rng1</a> &gt;, borrowed_iterator_t&lt; <a class="el" href="class_rng2.html">Rng2</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafa48d0e7d2e6042cee0d250875e513d3">ranges::swap_ranges</a> (<a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;rng2)</td></tr>
<tr class="separator:gafa48d0e7d2e6042cee0d250875e513d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac943a6f5b167780349d4444f08a32ec9"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gac943a6f5b167780349d4444f08a32ec9"><td class="memTemplItemLeft" align="right" valign="top">unary_transform_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac943a6f5b167780349d4444f08a32ec9">ranges::transform</a> (I first, S last, O out, F fun, P proj=P{})</td></tr>
<tr class="memdesc:gac943a6f5b167780349d4444f08a32ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>transform</code>  <a href="group__group-algorithms.html#gac943a6f5b167780349d4444f08a32ec9">More...</a><br /></td></tr>
<tr class="separator:gac943a6f5b167780349d4444f08a32ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga350c9661e3f88f03991b07c9e7ef37c3"><td class="memTemplParams" colspan="2">template&lt;typename I0 , typename S0 , typename I1 , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga350c9661e3f88f03991b07c9e7ef37c3"><td class="memTemplItemLeft" align="right" valign="top">binary_transform_result&lt; I0, I1, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga350c9661e3f88f03991b07c9e7ef37c3">ranges::transform</a> (I0 begin0, S0 end0, I1 begin1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga350c9661e3f88f03991b07c9e7ef37c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga350c9661e3f88f03991b07c9e7ef37c3">More...</a><br /></td></tr>
<tr class="separator:ga350c9661e3f88f03991b07c9e7ef37c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b62572c5222d42401b35fdf9c0a473"><td class="memTemplParams" colspan="2">template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:gad6b62572c5222d42401b35fdf9c0a473"><td class="memTemplItemLeft" align="right" valign="top">binary_transform_result&lt; I0, I1, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad6b62572c5222d42401b35fdf9c0a473">ranges::transform</a> (I0 begin0, S0 end0, I1 begin1, S1 end1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:gad6b62572c5222d42401b35fdf9c0a473"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gad6b62572c5222d42401b35fdf9c0a473">More...</a><br /></td></tr>
<tr class="separator:gad6b62572c5222d42401b35fdf9c0a473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga498202023a2c6ad47bdb9a5f887c1396"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga498202023a2c6ad47bdb9a5f887c1396"><td class="memTemplItemLeft" align="right" valign="top">unary_transform_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga498202023a2c6ad47bdb9a5f887c1396">ranges::transform</a> (Rng &amp;&amp;rng, O out, F fun, P proj=P{})</td></tr>
<tr class="memdesc:ga498202023a2c6ad47bdb9a5f887c1396"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga498202023a2c6ad47bdb9a5f887c1396">More...</a><br /></td></tr>
<tr class="separator:ga498202023a2c6ad47bdb9a5f887c1396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529fe0621f3e1cf401a30caf1a28656d"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename I1Ref , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga529fe0621f3e1cf401a30caf1a28656d"><td class="memTemplItemLeft" align="right" valign="top">binary_transform_result&lt; borrowed_iterator_t&lt; Rng0 &gt;, uncvref_t&lt; I1Ref &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga529fe0621f3e1cf401a30caf1a28656d">ranges::transform</a> (Rng0 &amp;&amp;rng0, I1Ref &amp;&amp;begin1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga529fe0621f3e1cf401a30caf1a28656d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga529fe0621f3e1cf401a30caf1a28656d">More...</a><br /></td></tr>
<tr class="separator:ga529fe0621f3e1cf401a30caf1a28656d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9affa19cbbfedf9e33dd6786ea6977da"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename Rng1 , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga9affa19cbbfedf9e33dd6786ea6977da"><td class="memTemplItemLeft" align="right" valign="top">binary_transform_result&lt; borrowed_iterator_t&lt; Rng0 &gt;, borrowed_iterator_t&lt; <a class="el" href="class_rng1.html">Rng1</a> &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9affa19cbbfedf9e33dd6786ea6977da">ranges::transform</a> (Rng0 &amp;&amp;rng0, <a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;rng1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga9affa19cbbfedf9e33dd6786ea6977da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga9affa19cbbfedf9e33dd6786ea6977da">More...</a><br /></td></tr>
<tr class="separator:ga9affa19cbbfedf9e33dd6786ea6977da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd30ade930a7ad87d648a1a6d431524c"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:gafd30ade930a7ad87d648a1a6d431524c"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafd30ade930a7ad87d648a1a6d431524c">ranges::unique</a> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gafd30ade930a7ad87d648a1a6d431524c"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>unique</code>  <a href="group__group-algorithms.html#gafd30ade930a7ad87d648a1a6d431524c">More...</a><br /></td></tr>
<tr class="separator:gafd30ade930a7ad87d648a1a6d431524c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8269b2eb3a23ae31e5b8cb357bcd68f8"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga8269b2eb3a23ae31e5b8cb357bcd68f8"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8269b2eb3a23ae31e5b8cb357bcd68f8">ranges::unique</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga8269b2eb3a23ae31e5b8cb357bcd68f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga8269b2eb3a23ae31e5b8cb357bcd68f8">More...</a><br /></td></tr>
<tr class="separator:ga8269b2eb3a23ae31e5b8cb357bcd68f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd248f3be96356cb6dff51d14bc6e65"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga3dd248f3be96356cb6dff51d14bc6e65"><td class="memTemplItemLeft" align="right" valign="top">unique_copy_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga3dd248f3be96356cb6dff51d14bc6e65">ranges::unique_copy</a> (I first, S last, O out, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga3dd248f3be96356cb6dff51d14bc6e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function unique_copy  <a href="group__group-algorithms.html#ga3dd248f3be96356cb6dff51d14bc6e65">More...</a><br /></td></tr>
<tr class="separator:ga3dd248f3be96356cb6dff51d14bc6e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd4603f5260f8c088a9baf919851ef0a"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:gafd4603f5260f8c088a9baf919851ef0a"><td class="memTemplItemLeft" align="right" valign="top">unique_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafd4603f5260f8c088a9baf919851ef0a">ranges::unique_copy</a> (Rng &amp;&amp;rng, O out, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gafd4603f5260f8c088a9baf919851ef0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#gafd4603f5260f8c088a9baf919851ef0a">More...</a><br /></td></tr>
<tr class="separator:gafd4603f5260f8c088a9baf919851ef0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76045249b0ecbf397dfd5f4c0e3d62e"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:gad76045249b0ecbf397dfd5f4c0e3d62e"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad76045249b0ecbf397dfd5f4c0e3d62e">ranges::unstable_remove_if</a> (I first, I last, C pred, P proj={})</td></tr>
<tr class="memdesc:gad76045249b0ecbf397dfd5f4c0e3d62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">unstable_remove have O(1) complexity for each element remove, unlike remove O(n) [for worst case]. Each erased element overwritten (moved in) with last one. unstable_remove_if does not preserve relative element order.  <a href="group__group-algorithms.html#gad76045249b0ecbf397dfd5f4c0e3d62e">More...</a><br /></td></tr>
<tr class="separator:gad76045249b0ecbf397dfd5f4c0e3d62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78222856ef024679c338b6ea320428d5"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga78222856ef024679c338b6ea320428d5"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga78222856ef024679c338b6ea320428d5">ranges::unstable_remove_if</a> (Rng &amp;&amp;rng, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga78222856ef024679c338b6ea320428d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga78222856ef024679c338b6ea320428d5">More...</a><br /></td></tr>
<tr class="separator:ga78222856ef024679c338b6ea320428d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga204b1d4892ec45dda000e1221b4db7f2"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga204b1d4892ec45dda000e1221b4db7f2"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga204b1d4892ec45dda000e1221b4db7f2">ranges::upper_bound</a> (I first, S last, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga204b1d4892ec45dda000e1221b4db7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>upper_bound</code>  <a href="group__group-algorithms.html#ga204b1d4892ec45dda000e1221b4db7f2">More...</a><br /></td></tr>
<tr class="separator:ga204b1d4892ec45dda000e1221b4db7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga996b58ea852d27030d7502dc01573243"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga996b58ea852d27030d7502dc01573243"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga996b58ea852d27030d7502dc01573243">ranges::upper_bound</a> (Rng &amp;&amp;rng, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga996b58ea852d27030d7502dc01573243"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga996b58ea852d27030d7502dc01573243">More...</a><br /></td></tr>
<tr class="separator:ga996b58ea852d27030d7502dc01573243"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9f338eb40255d46cf3bc23880bb9e158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f338eb40255d46cf3bc23880bb9e158">&#9670;&nbsp;</a></span>adjacent_find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="adjacent__find_8hpp.html">range/v3/algorithm/adjacent_find.hpp</a>&gt;</code></p>

<p>function template <code>adjacent_find</code> </p>
<p>range-based version of the <code>adjacent_find</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>C</code> is a model of the <code>BinaryPredicate</code> concept </dd>
<dd>
requires <code>forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga8995966d9a73963ceef94a1def806afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8995966d9a73963ceef94a1def806afb">&#9670;&nbsp;</a></span>adjacent_find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="adjacent__find_8hpp.html">range/v3/algorithm/adjacent_find.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga17787a877c8833e0eb458e5a6a3faaca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17787a877c8833e0eb458e5a6a3faaca">&#9670;&nbsp;</a></span>adjacent_remove_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename Pred , typename Proj  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::adjacent_remove_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>pred</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2adjacent__remove__if_8hpp.html">range/v3/algorithm/adjacent_remove_if.hpp</a>&gt;</code></p>

<p>function <code>adjacent_remove_if</code> </p>
<p>range-based version of the <code>adjacent_remove_if</code> algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept. </dd>
<dd>
<code>Pred</code> is a model of the <code>BinaryPredicate</code> concept. </dd>
<dd>
requires <code>permutable&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;Pred, projected&lt;I, Proj&gt;&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-algorithms.html#ga18c2482a1c31a536469f5aa44a12f35e">ranges::adjacent_remove_if()</a>.</p>

</div>
</div>
<a id="ga18c2482a1c31a536469f5aa44a12f35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18c2482a1c31a536469f5aa44a12f35e">&#9670;&nbsp;</a></span>adjacent_remove_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename Pred , typename Proj  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::adjacent_remove_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2adjacent__remove__if_8hpp.html">range/v3/algorithm/adjacent_remove_if.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; indirect_relation&lt;Pred, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt;</code> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__group-algorithms.html#ga17787a877c8833e0eb458e5a6a3faaca">ranges::adjacent_remove_if()</a>.</p>

</div>
</div>
<a id="ga20fa53067b188fd2450ef6aad3399e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20fa53067b188fd2450ef6aad3399e8a">&#9670;&nbsp;</a></span>all_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::all_of </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="all__of_8hpp.html">range/v3/algorithm/all_of.hpp</a>&gt;</code></p>

<p>function template <code>all_of</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga10a043d951f87ab620aa7a90d2c638a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10a043d951f87ab620aa7a90d2c638a2">&#9670;&nbsp;</a></span>all_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::all_of </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="all__of_8hpp.html">range/v3/algorithm/all_of.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga7962f79cf7e734084c5762f6f2d3e8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7962f79cf7e734084c5762f6f2d3e8c5">&#9670;&nbsp;</a></span>any_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::any_of </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="any__of_8hpp.html">range/v3/algorithm/any_of.hpp</a>&gt;</code></p>

<p>function template <code>any_of</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gae3c0d932766db4d6215a3b892349b60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3c0d932766db4d6215a3b892349b60a">&#9670;&nbsp;</a></span>any_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::any_of </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="any__of_8hpp.html">range/v3/algorithm/any_of.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gada2992c6d8624aa4e4103cecc5b71d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada2992c6d8624aa4e4103cecc5b71d5e">&#9670;&nbsp;</a></span>binary_search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::binary_search </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="binary__search_8hpp.html">range/v3/algorithm/binary_search.hpp</a>&gt;</code></p>

<p>function template <code>binary_search</code> </p>
<p>range-based version of the <code>binary_search</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
requires <code>forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gac8afb8715289bbf439937fc396f330ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8afb8715289bbf439937fc396f330ee">&#9670;&nbsp;</a></span>binary_search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::binary_search </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="binary__search_8hpp.html">range/v3/algorithm/binary_search.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga12a778db69e558efc9306c5c73f74fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12a778db69e558efc9306c5c73f74fbd">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename T , typename P  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ranges::contains </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="contains_8hpp.html">range/v3/algorithm/contains.hpp</a>&gt;</code></p>

<p>function template <code>contains</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, const T *&gt;</code> </dd></dl>

</div>
</div>
<a id="ga2a64319807ba7e276e49f9411c3f6dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a64319807ba7e276e49f9411c3f6dd1">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename T , typename P  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ranges::contains </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="contains_8hpp.html">range/v3/algorithm/contains.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, const T *&gt;</code> </dd></dl>

</div>
</div>
<a id="gac1663f9fd1985e4095d958b39b0f4f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1663f9fd1985e4095d958b39b0f4f4e">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr copy_result&lt;I, O&gt; ranges::copy </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2copy_8hpp.html">range/v3/algorithm/copy.hpp</a>&gt;</code></p>

<p>function template <code>copy</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</code> </dd></dl>

</div>
</div>
<a id="ga1326d7b2387f69dc2ab35ba854691655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1326d7b2387f69dc2ab35ba854691655">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr copy_result&lt;borrowed_iterator_t&lt;Rng&gt;, O&gt; ranges::copy </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2copy_8hpp.html">range/v3/algorithm/copy.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</code> </dd></dl>

</div>
</div>
<a id="ga41a276d8c27d9c0d6ed6ea7a15dd4610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41a276d8c27d9c0d6ed6ea7a15dd4610">&#9670;&nbsp;</a></span>copy_backward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">copy_backward_result&lt;I, O&gt; ranges::copy_backward </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>end_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="copy__backward_8hpp.html">range/v3/algorithm/copy_backward.hpp</a>&gt;</code></p>

<p>function template <code>copy_backward</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; bidirectional_iterator&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</code> </dd></dl>

</div>
</div>
<a id="gad76c787c8e4e65676eaaf44113584013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad76c787c8e4e65676eaaf44113584013">&#9670;&nbsp;</a></span>copy_backward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">copy_backward_result&lt;borrowed_iterator_t&lt;Rng&gt;, O&gt; ranges::copy_backward </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="copy__backward_8hpp.html">range/v3/algorithm/copy_backward.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_range&lt;Rng&gt; &amp;&amp; bidirectional_iterator&lt;O&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</code> </dd></dl>

</div>
</div>
<a id="gaf3817fe93ed0a1196bbba995198dd109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3817fe93ed0a1196bbba995198dd109">&#9670;&nbsp;</a></span>copy_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">copy_if_result&lt;I, O&gt; ranges::copy_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="copy__if_8hpp.html">range/v3/algorithm/copy_if.hpp</a>&gt;</code></p>

<p>function template <code>copy_if</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</code> </dd></dl>

</div>
</div>
<a id="ga36a0fa6e08d83f6cf93b41faf86b1ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36a0fa6e08d83f6cf93b41faf86b1ad8">&#9670;&nbsp;</a></span>copy_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">copy_if_result&lt;borrowed_iterator_t&lt;Rng&gt;, O&gt; ranges::copy_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="copy__if_8hpp.html">range/v3/algorithm/copy_if.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</code> </dd></dl>

</div>
</div>
<a id="gab9388d799b1a2a3e38cba8313cf10242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9388d799b1a2a3e38cba8313cf10242">&#9670;&nbsp;</a></span>copy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">copy_n_result&lt;I, O&gt; ranges::copy_n </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iter_difference_t&lt; I &gt;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="copy__n_8hpp.html">range/v3/algorithm/copy_n.hpp</a>&gt;</code></p>

<p>function template <code>copy_n</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</code> </dd></dl>

</div>
</div>
<a id="gabd70792bcd1a2402b02ac1ab4ec9e3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd70792bcd1a2402b02ac1ab4ec9e3f3">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename V , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iter_difference_t&lt;I&gt; ranges::count </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="count_8hpp.html">range/v3/algorithm/count.hpp</a>&gt;</code></p>

<p>function template <code>count</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, V const *&gt;</code> </dd></dl>

</div>
</div>
<a id="gac0caa54ba4075685b569b33b2073668a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0caa54ba4075685b569b33b2073668a">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iter_difference_t&lt;iterator_t&lt;Rng&gt; &gt; ranges::count </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="count_8hpp.html">range/v3/algorithm/count.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, V const *&gt;</code> </dd></dl>

</div>
</div>
<a id="ga54810215f562a3cf1248243591c566d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54810215f562a3cf1248243591c566d7">&#9670;&nbsp;</a></span>count_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename R , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iter_difference_t&lt;I&gt; ranges::count_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="count__if_8hpp.html">range/v3/algorithm/count_if.hpp</a>&gt;</code></p>

<p>function template <code>count_if</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;R, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga6fbe1cf9461e62efd96562d4c25a13c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fbe1cf9461e62efd96562d4c25a13c7">&#9670;&nbsp;</a></span>count_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename R , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iter_difference_t&lt;iterator_t&lt;Rng&gt; &gt; ranges::count_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="count__if_8hpp.html">range/v3/algorithm/count_if.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;R, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga90cf0d62c417da4f3e3ed9a94a795b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90cf0d62c417da4f3e3ed9a94a795b43">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ranges::ends_with </td>
          <td>(</td>
          <td class="paramtype">I0&#160;</td>
          <td class="paramname"><em>begin0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S0&#160;</td>
          <td class="paramname"><em>end0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="ends__with_8hpp.html">range/v3/algorithm/ends_with.hpp</a>&gt;</code></p>

<p>function template <code>ends_with</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>((forward_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt;) || (input_iterator&lt;I0&gt; &amp;&amp; sized_sentinel_for&lt;S0, I0&gt;)) &amp;&amp; ((forward_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt;) || (input_iterator&lt;I1&gt; &amp;&amp; sized_sentinel_for&lt;S1, I1&gt;)) &amp;&amp; indirectly_comparable&lt;I0, I1, C, P0, P1&gt;</code> </dd></dl>

</div>
</div>
<a id="ga2cf2508147804f574487d05cd3ec7773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cf2508147804f574487d05cd3ec7773">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename Rng1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ranges::ends_with </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="ends__with_8hpp.html">range/v3/algorithm/ends_with.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>(forward_range&lt;Rng0&gt; || (input_range&lt;Rng0&gt; &amp;&amp; sized_range&lt;Rng0&gt;)) &amp;&amp; (forward_range&lt;Rng1&gt; || (input_range&lt;Rng1&gt; &amp;&amp; sized_range&lt;Rng1&gt;)) &amp;&amp; indirectly_comparable&lt;iterator_t&lt;Rng0&gt;, iterator_t&lt;Rng1&gt;, C, P0, P1&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-iterator.html#gaa5892e49da80688f61e93faf07c98746">ranges::distance</a>, <a class="el" href="group__group-algorithms.html#ga621fce80ba6d420dd3b61ed697001bd9">ranges::equal()</a>, <a class="el" href="group__group-utility.html#ga20b5b25347e7f8173b2118fdb5ea5f58">ranges::aux::move</a>, and <a class="el" href="group__group-iterator.html#gaf136ff254688f2c24f5c5f58df7ff56d">ranges::next</a>.</p>

</div>
</div>
<a id="ga621fce80ba6d420dd3b61ed697001bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga621fce80ba6d420dd3b61ed697001bd9">&#9670;&nbsp;</a></span>equal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I0 , typename S0 , typename I1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ranges::equal </td>
          <td>(</td>
          <td class="paramtype">I0&#160;</td>
          <td class="paramname"><em>begin0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S0&#160;</td>
          <td class="paramname"><em>end0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="equal_8hpp.html">range/v3/algorithm/equal.hpp</a>&gt;</code></p>

<p>function template <code>equal</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp; input_iterator&lt;I1&gt; &amp;&amp; indirectly_comparable&lt;I0, I1, C, P0, P1&gt;</code> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__group-algorithms.html#ga2cf2508147804f574487d05cd3ec7773">ranges::ends_with()</a>.</p>

</div>
</div>
<a id="ga25945a5e9eefc803e0c88435db3a9c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25945a5e9eefc803e0c88435db3a9c80">&#9670;&nbsp;</a></span>equal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ranges::equal </td>
          <td>(</td>
          <td class="paramtype">I0&#160;</td>
          <td class="paramname"><em>begin0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S0&#160;</td>
          <td class="paramname"><em>end0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="equal_8hpp.html">range/v3/algorithm/equal.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp; input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; indirectly_comparable&lt;I0, I1, C, P0, P1&gt;</code> </dd></dl>

</div>
</div>
<a id="ga40640a7e413ef93779f51096f16a88b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40640a7e413ef93779f51096f16a88b3">&#9670;&nbsp;</a></span>equal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename I1Ref , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ranges::equal </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1Ref &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="equal_8hpp.html">range/v3/algorithm/equal.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng0&gt; &amp;&amp; input_iterator&lt;uncvref_t&lt;I1Ref&gt;&gt; &amp;&amp; indirectly_comparable&lt;iterator_t&lt;Rng0&gt;, uncvref_t&lt;I1Ref&gt;, C, P0, P1&gt;</code> </dd></dl>

</div>
</div>
<a id="ga796348f9ecfb8077a06e7db8e18ff6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga796348f9ecfb8077a06e7db8e18ff6e7">&#9670;&nbsp;</a></span>equal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename Rng1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ranges::equal </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="equal_8hpp.html">range/v3/algorithm/equal.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng0&gt; &amp;&amp; input_range&lt;Rng1&gt; &amp;&amp; indirectly_comparable&lt;iterator_t&lt;Rng0&gt;, iterator_t&lt;Rng1&gt;, C, P0, P1&gt;</code> </dd></dl>

</div>
</div>
<a id="ga065f5921adf8d8bb16e4e1e7cffe1427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga065f5921adf8d8bb16e4e1e7cffe1427">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structranges_1_1subrange.html">subrange</a>&lt;I&gt; ranges::equal_range </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="equal__range_8hpp.html">range/v3/algorithm/equal_range.hpp</a>&gt;</code></p>

<p>function template <code>equal_range</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga8216954d56c08c873093b610e3c09d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8216954d56c08c873093b610e3c09d1f">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_subrange_t&lt;Rng&gt; ranges::equal_range </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="equal__range_8hpp.html">range/v3/algorithm/equal_range.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gaec88f204b6e7be401afc2421011ea22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec88f204b6e7be401afc2421011ea22f">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename O , typename S , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">O ranges::fill </td>
          <td>(</td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fill_8hpp.html">range/v3/algorithm/fill.hpp</a>&gt;</code></p>

<p>function template <code>fill</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>output_iterator&lt;O, V const &amp;&gt; &amp;&amp; sentinel_for&lt;S, O&gt;</code> </dd></dl>

</div>
</div>
<a id="ga7163c7732174455f295f7d1437f072a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7163c7732174455f295f7d1437f072a1">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::fill </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fill_8hpp.html">range/v3/algorithm/fill.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>output_range&lt;Rng, V const &amp;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga78f04fdbc6e4b411e565832b64c9f9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78f04fdbc6e4b411e565832b64c9f9df">&#9670;&nbsp;</a></span>fill_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename O , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">O ranges::fill_n </td>
          <td>(</td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iter_difference_t&lt; O &gt;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fill__n_8hpp.html">range/v3/algorithm/fill_n.hpp</a>&gt;</code></p>

<p>function template <code>equal</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>output_iterator&lt;O, V const &amp;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga1d8e4a9998178c6c21c7bd2683cab4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d8e4a9998178c6c21c7bd2683cab4ce">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename V , typename P  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr I ranges::find </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find_8hpp.html">range/v3/algorithm/find.hpp</a>&gt;</code></p>

<p>template function <code>find</code> </p>
<p>range-based version of the <code>find</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>input_iterator</code> concept </dd>
<dd>
<code>S</code> is a model of the <code>sentinel_for&lt;I&gt;</code> concept </dd>
<dd>
<code>P</code> is a model of the <code>invocable&lt;iter_common_reference_t&lt;I&gt;&gt;</code> concept </dd>
<dd>
The ResultType of <code>P</code> is equality_comparable with V </dd>
<dd>
requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, V const *&gt;</code> </dd></dl>

</div>
</div>
<a id="ga08e617e1003f24a0cf9e25119fded9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08e617e1003f24a0cf9e25119fded9e8">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V , typename P  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr borrowed_iterator_t&lt;Rng&gt; ranges::find </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find_8hpp.html">range/v3/algorithm/find.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, V const *&gt;</code> </dd></dl>

</div>
</div>
<a id="ga03f0f8c9bcb0559fbb0dd40255d913d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03f0f8c9bcb0559fbb0dd40255d913d5">&#9670;&nbsp;</a></span>find_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename R  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structranges_1_1subrange.html">subrange</a>&lt;I1&gt; ranges::find_end </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>pred</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__end_8hpp.html">range/v3/algorithm/find_end.hpp</a>&gt;</code></p>

<p>function template <code>find_end</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; forward_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; indirect_relation&lt;R, projected&lt;I1, P&gt;, I2&gt;</code> </dd></dl>

</div>
</div>
<a id="gaa63967ca547c5eb02bdce496f431baa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa63967ca547c5eb02bdce496f431baa1">&#9670;&nbsp;</a></span>find_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename R  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_subrange_t&lt;<a class="el" href="class_rng1.html">Rng1</a>&gt; ranges::find_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>pred</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__end_8hpp.html">range/v3/algorithm/find_end.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng1&gt; &amp;&amp; forward_range&lt;Rng2&gt; &amp;&amp; indirect_relation&lt;R, projected&lt;iterator_t&lt;Rng1&gt;, P&gt;, iterator_t&lt;Rng2&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gab988e235a1c284d69a91f3c7faa05265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab988e235a1c284d69a91f3c7faa05265">&#9670;&nbsp;</a></span>find_first_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename R  = equal_to, typename P0  = identity, typename P1  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr I0 ranges::find_first_of </td>
          <td>(</td>
          <td class="paramtype">I0&#160;</td>
          <td class="paramname"><em>begin0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S0&#160;</td>
          <td class="paramname"><em>end0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>pred</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__first__of_8hpp.html">range/v3/algorithm/find_first_of.hpp</a>&gt;</code></p>

<p>function template <code>find_first_of</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp; forward_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; indirect_relation&lt;R, projected&lt;I0, P0&gt;, projected&lt;I1, P1&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga5b5cacc679ba0e755519252a6f4f15cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b5cacc679ba0e755519252a6f4f15cd">&#9670;&nbsp;</a></span>find_first_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename Rng1 , typename R  = equal_to, typename P0  = identity, typename P1  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr borrowed_iterator_t&lt;Rng0&gt; ranges::find_first_of </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>pred</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__first__of_8hpp.html">range/v3/algorithm/find_first_of.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng0&gt; &amp;&amp; forward_range&lt;Rng1&gt; &amp;&amp; indirect_relation&lt;R, projected&lt;iterator_t&lt;Rng0&gt;, P0&gt;, projected&lt;iterator_t&lt;Rng1&gt;, P1&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gae21556995847a86ff6ce62a5f8ab5a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae21556995847a86ff6ce62a5f8ab5a8b">&#9670;&nbsp;</a></span>find_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::find_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__if_8hpp.html">range/v3/algorithm/find_if.hpp</a>&gt;</code></p>

<p>template function <code>find</code> </p>
<p>range-based version of the <code>find</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>input_iterator</code> concept </dd>
<dd>
<code>S</code> is a model of the <code>sentinel_for&lt;I&gt;</code> concept </dd>
<dd>
<code>P</code> is a model of the <code>invocable&lt;V&gt;</code> concept, where <code>V</code> is the value type of I. </dd>
<dd>
<code>F</code> models <code>predicate&lt;X&gt;</code>, where <code>X</code> is the result type of <code>invocable&lt;P, V&gt;</code> </dd>
<dd>
requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga1c615adb2ae6c22dbef6d3e9862964b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c615adb2ae6c22dbef6d3e9862964b9">&#9670;&nbsp;</a></span>find_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::find_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__if_8hpp.html">range/v3/algorithm/find_if.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gac08351568fba29a2a2ee2b0ef8822450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac08351568fba29a2a2ee2b0ef8822450">&#9670;&nbsp;</a></span>find_if_not() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::find_if_not </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__if__not_8hpp.html">range/v3/algorithm/find_if_not.hpp</a>&gt;</code></p>

<p>template function <code>find_if_not</code> </p>
<p>range-based version of the <code>find_if_not</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>input_iterator</code> concept </dd>
<dd>
<code>S</code> is a model of the <code>sentinel_for&lt;I&gt;</code> concept </dd>
<dd>
<code>P</code> is a model of the <code>invocable&lt;V&gt;</code> concept, where <code>V</code> is the value type of I. </dd>
<dd>
<code>F</code> models <code>predicate&lt;X&gt;</code>, where <code>X</code> is the result type of <code>invocable&lt;P, V&gt;</code> </dd>
<dd>
requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gaae352ef5e361b81eb7e1a05e8d3b3504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae352ef5e361b81eb7e1a05e8d3b3504">&#9670;&nbsp;</a></span>find_if_not() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::find_if_not </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__if__not_8hpp.html">range/v3/algorithm/find_if_not.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gae3c75ca4aaf36d30c1122f51db99d505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3c75ca4aaf36d30c1122f51db99d505">&#9670;&nbsp;</a></span>for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">for_each_result&lt;I, F&gt; ranges::for_each </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2for__each_8hpp.html">range/v3/algorithm/for_each.hpp</a>&gt;</code></p>

<p>function template <code>for_each</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirectly_unary_invocable&lt;F, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gac74c95463754807206a1a1432eb20368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac74c95463754807206a1a1432eb20368">&#9670;&nbsp;</a></span>for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">for_each_result&lt;borrowed_iterator_t&lt;Rng&gt;, F&gt; ranges::for_each </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2for__each_8hpp.html">range/v3/algorithm/for_each.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirectly_unary_invocable&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga0040ffc33d08505809fffa5aea8c9103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0040ffc33d08505809fffa5aea8c9103">&#9670;&nbsp;</a></span>for_each_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::for_each_n </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iter_difference_t&lt; I &gt;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="for__each__n_8hpp.html">range/v3/algorithm/for_each_n.hpp</a>&gt;</code></p>

<p>function template <code>for_each_n</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; indirectly_unary_invocable&lt;F, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga12cc578de361ba8aea4c3efc9181bdaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12cc578de361ba8aea4c3efc9181bdaf">&#9670;&nbsp;</a></span>for_each_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::for_each_n </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">range_difference_t&lt; Rng &gt;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="for__each__n_8hpp.html">range/v3/algorithm/for_each_n.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirectly_unary_invocable&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gab3b351c6b515474d913cf3054cacba2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3b351c6b515474d913cf3054cacba2d">&#9670;&nbsp;</a></span>generate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename O , typename S , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">generate_result&lt;O, F&gt; ranges::generate </td>
          <td>(</td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2generate_8hpp.html">range/v3/algorithm/generate.hpp</a>&gt;</code></p>

<p>function template <code>generate_n</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>invocable&lt;F &amp;&gt; &amp;&amp; output_iterator&lt;O, invoke_result_t&lt;F &amp;&gt;&gt; &amp;&amp; sentinel_for&lt;S, O&gt;</code> </dd></dl>

</div>
</div>
<a id="ga8299db3094590afff7a963e2bba9cb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8299db3094590afff7a963e2bba9cb9a">&#9670;&nbsp;</a></span>generate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">generate_result&lt;borrowed_iterator_t&lt;Rng&gt;, F&gt; ranges::generate </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2generate_8hpp.html">range/v3/algorithm/generate.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>invocable&lt;F &amp;&gt; &amp;&amp; output_range&lt;Rng, invoke_result_t&lt;F &amp;&gt;&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-utility.html#ga20b5b25347e7f8173b2118fdb5ea5f58">ranges::aux::move</a>.</p>

</div>
</div>
<a id="ga248c2ba6e27f05e9737df5baa2612d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga248c2ba6e27f05e9737df5baa2612d33">&#9670;&nbsp;</a></span>generate_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename O , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">generate_n_result&lt;O, F&gt; ranges::generate_n </td>
          <td>(</td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iter_difference_t&lt; O &gt;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2generate__n_8hpp.html">range/v3/algorithm/generate_n.hpp</a>&gt;</code></p>

<p>function template <code>generate_n</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>invocable&lt;F &amp;&gt; &amp;&amp; output_iterator&lt;O, invoke_result_t&lt;F &amp;&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga0d45f4d8cc9d64ca2d50599557dda022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d45f4d8cc9d64ca2d50599557dda022">&#9670;&nbsp;</a></span>includes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::includes </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>

<p>function template <code>includes</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; input_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-algorithms.html#ga4a0bd1b89f2e0ff2accb96348a8191d9">ranges::includes()</a>.</p>

</div>
</div>
<a id="ga4a0bd1b89f2e0ff2accb96348a8191d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a0bd1b89f2e0ff2accb96348a8191d9">&#9670;&nbsp;</a></span>includes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::includes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng1&gt; &amp;&amp; input_range&lt;Rng2&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng1&gt;, P1&gt;, projected&lt;iterator_t&lt;Rng2&gt;, P2&gt;&gt;</code> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__group-algorithms.html#ga0d45f4d8cc9d64ca2d50599557dda022">ranges::includes()</a>.</p>

</div>
</div>
<a id="ga69be23f01a954678edc58683dd2b4f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69be23f01a954678edc58683dd2b4f7f">&#9670;&nbsp;</a></span>inplace_merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::inplace_merge </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="inplace__merge_8hpp.html">range/v3/algorithm/inplace_merge.hpp</a>&gt;</code></p>

<p>function template <code>inplace_merge</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_iterator&lt;I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</code> </dd></dl>

</div>
</div>
<a id="gac5d8910229da062514994ec67724fa90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d8910229da062514994ec67724fa90">&#9670;&nbsp;</a></span>inplace_merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::inplace_merge </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_t&lt; Rng &gt;&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="inplace__merge_8hpp.html">range/v3/algorithm/inplace_merge.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</code> </dd></dl>

</div>
</div>
<a id="ga474185e41e367f882df757dd9cc768b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga474185e41e367f882df757dd9cc768b2">&#9670;&nbsp;</a></span>is_heap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::is_heap </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>

<p>function template <code>is_heap</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga735cff63efdf19dc2dc4123fd24899d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga735cff63efdf19dc2dc4123fd24899d7">&#9670;&nbsp;</a></span>is_heap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::is_heap </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga1ad0398ff5571b8c1ce52d3704d2ce6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ad0398ff5571b8c1ce52d3704d2ce6a">&#9670;&nbsp;</a></span>is_heap_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::is_heap_until </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>

<p>function template <code>is_heap_until</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga4a4a82bdf4ade758e2b78415bda5b982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a4a82bdf4ade758e2b78415bda5b982">&#9670;&nbsp;</a></span>is_heap_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::is_heap_until </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gaa1612e6e4cf8c166a994ae78c04f0572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1612e6e4cf8c166a994ae78c04f0572">&#9670;&nbsp;</a></span>is_partitioned() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::is_partitioned </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__partitioned_8hpp.html">range/v3/algorithm/is_partitioned.hpp</a>&gt;</code></p>

<p>function template <code>is_partitioned</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga641b741cfd1cf9e4c095e86b747ead80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga641b741cfd1cf9e4c095e86b747ead80">&#9670;&nbsp;</a></span>is_partitioned() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::is_partitioned </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__partitioned_8hpp.html">range/v3/algorithm/is_partitioned.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gace8e1df9f2c8c5c1a0afb8fb9dfe812e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace8e1df9f2c8c5c1a0afb8fb9dfe812e">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::is_permutation </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="permutation_8hpp.html">range/v3/algorithm/permutation.hpp</a>&gt;</code></p>

<p>function template <code>is_permutation</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; forward_iterator&lt;I2&gt; &amp;&amp; indirectly_comparable&lt;I1, I2, C, P1, P2&gt;</code> </dd></dl>

</div>
</div>
<a id="ga6a6c585adfd745b93984902ccc873c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a6c585adfd745b93984902ccc873c8a">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::is_permutation </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="permutation_8hpp.html">range/v3/algorithm/permutation.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; forward_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; indirectly_comparable&lt;I1, I2, C, P1, P2&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-iterator.html#gaf136ff254688f2c24f5c5f58df7ff56d">ranges::next</a>.</p>

</div>
</div>
<a id="gaa1b063fb051f167be4b775324af35217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1b063fb051f167be4b775324af35217">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename I2Ref , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::is_permutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2Ref &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="permutation_8hpp.html">range/v3/algorithm/permutation.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng1&gt; &amp;&amp; forward_iterator&lt;uncvref_t&lt;I2Ref&gt;&gt; &amp;&amp; indirectly_comparable&lt;iterator_t&lt;Rng1&gt;, uncvref_t&lt;I2Ref&gt;, C, P1, P2&gt;</code> </dd></dl>

</div>
</div>
<a id="ga8e799a1d75267d3fc2764c4d6e16e43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e799a1d75267d3fc2764c4d6e16e43f">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::is_permutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="permutation_8hpp.html">range/v3/algorithm/permutation.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng1&gt; &amp;&amp; forward_range&lt;Rng2&gt; &amp;&amp; indirectly_comparable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, C, P1, P2&gt;</code> </dd></dl>

</div>
</div>
<a id="gad73a64c5b5fac2100034b2af5654f876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad73a64c5b5fac2100034b2af5654f876">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename R  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::is_sorted </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>rel</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__sorted_8hpp.html">range/v3/algorithm/is_sorted.hpp</a>&gt;</code></p>

<p>template function <code>is_sorted</code> </p>
<p>range-based version of the <code>is_sorted</code> std algorithm</p>
<p>Works on forward_ranges</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>forward_iterator</code> concept </dd>
<dd>
<code>S</code> and <code>I</code> model the <code>sentinel_for&lt;S, I&gt;</code> concept </dd>
<dd>
<code>R</code> and <code>projected&lt;I, P&gt;</code> model the <code>indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;</code> concept </dd>
<dd>
requires <code>forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga767102d6d607a8e22afea5145987511e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga767102d6d607a8e22afea5145987511e">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename R  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::is_sorted </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>rel</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__sorted_8hpp.html">range/v3/algorithm/is_sorted.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;R, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gaa315dfc9c44126707ff144552e7236cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa315dfc9c44126707ff144552e7236cf">&#9670;&nbsp;</a></span>is_sorted_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename R  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>pred</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__sorted__until_8hpp.html">range/v3/algorithm/is_sorted_until.hpp</a>&gt;</code></p>

<p>template function <code>is_sorted_until</code> </p>
<p>range-based version of the <code>is_sorted_until</code> std algorithm</p>
<p>Works on forward_ranges</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>forward_iterator</code> concept </dd>
<dd>
<code>S</code> and <code>I</code> model the <code>sentinel_for&lt;S, I&gt;</code> concept </dd>
<dd>
<code>R</code> and <code>projected&lt;I, P&gt;</code> model the <code>indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;</code> concept </dd>
<dd>
requires <code>forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga9f56b8373932148bb8eace8f3f9dee6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f56b8373932148bb8eace8f3f9dee6c">&#9670;&nbsp;</a></span>is_sorted_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename R  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>pred</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__sorted__until_8hpp.html">range/v3/algorithm/is_sorted_until.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;R, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga2c748435b0fff2d24e76bc08a97b10c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c748435b0fff2d24e76bc08a97b10c7">&#9670;&nbsp;</a></span>lexicographical_compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename C  = less, typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">I0&#160;</td>
          <td class="paramname"><em>begin0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S0&#160;</td>
          <td class="paramname"><em>end0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lexicographical__compare_8hpp.html">range/v3/algorithm/lexicographical_compare.hpp</a>&gt;</code></p>

<p>function template <code>lexicographical_compare</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp; input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I0, P0&gt;, projected&lt;I1, P1&gt;&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-algorithms.html#ga136e96f17657d77a6259d87c70e048e7">ranges::lexicographical_compare()</a>.</p>

</div>
</div>
<a id="ga136e96f17657d77a6259d87c70e048e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga136e96f17657d77a6259d87c70e048e7">&#9670;&nbsp;</a></span>lexicographical_compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename Rng1 , typename C  = less, typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lexicographical__compare_8hpp.html">range/v3/algorithm/lexicographical_compare.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng0&gt; &amp;&amp; input_range&lt;Rng1&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng0&gt;, P0&gt;, projected&lt;iterator_t&lt;Rng1&gt;, P1&gt;&gt;</code> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__group-algorithms.html#ga2c748435b0fff2d24e76bc08a97b10c7">ranges::lexicographical_compare()</a>.</p>

</div>
</div>
<a id="gadac559e70dbb049bbb03be98039e2114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadac559e70dbb049bbb03be98039e2114">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::lower_bound </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lower__bound_8hpp.html">range/v3/algorithm/lower_bound.hpp</a>&gt;</code></p>

<p>function template <code>lower_bound</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga660e7a35e981781951b4de7fff544802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga660e7a35e981781951b4de7fff544802">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::lower_bound </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lower__bound_8hpp.html">range/v3/algorithm/lower_bound.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-utility.html#ga20b5b25347e7f8173b2118fdb5ea5f58">ranges::aux::move</a>, and <a class="el" href="group__group-algorithms.html#ga46862e538efe454cea0319c4eb4a0971">ranges::partition_point()</a>.</p>

</div>
</div>
<a id="ga262acf8b1a6f9d0bfd35a20fcb474c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga262acf8b1a6f9d0bfd35a20fcb474c51">&#9670;&nbsp;</a></span>make_heap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::make_heap </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>

<p>function template <code>make_heap</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</code> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__group-algorithms.html#gadc26b2da998f1c2610be46785d691965">ranges::partial_sort_copy()</a>.</p>

</div>
</div>
<a id="gab268c150c78da5990cfcce27bfd26d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab268c150c78da5990cfcce27bfd26d65">&#9670;&nbsp;</a></span>make_heap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::make_heap </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</code> </dd></dl>

</div>
</div>
<a id="ga7cb7f0a7eb4226d8d0550bcf49016216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cb7f0a7eb4226d8d0550bcf49016216">&#9670;&nbsp;</a></span>max() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr range_value_t&lt;Rng&gt; ranges::max </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="max_8hpp.html">range/v3/algorithm/max.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; indirectly_copyable_storable&lt;iterator_t&lt;Rng&gt;, range_value_t&lt;Rng&gt; *&gt;</code> </dd></dl>

</div>
</div>
<a id="ga557aae406d07b1b8a5f9edbac03721fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga557aae406d07b1b8a5f9edbac03721fe">&#9670;&nbsp;</a></span>max() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C  = less, typename P  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T ranges::max </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt; const &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="max_8hpp.html">range/v3/algorithm/max.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>copyable&lt;T&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga81c8fc3325290fecf6048b61878f6e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81c8fc3325290fecf6048b61878f6e99">&#9670;&nbsp;</a></span>max() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C  = less, typename P  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T const&amp; ranges::max </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="max_8hpp.html">range/v3/algorithm/max.hpp</a>&gt;</code></p>

<p>function template <code>max</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gac318ca1ff2aac7fbd59c306724654159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac318ca1ff2aac7fbd59c306724654159">&#9670;&nbsp;</a></span>max_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::max_element </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="max__element_8hpp.html">range/v3/algorithm/max_element.hpp</a>&gt;</code></p>

<p>function template <code>max_element</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga72e2ede6a46d969e81364ec4eb8a2467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72e2ede6a46d969e81364ec4eb8a2467">&#9670;&nbsp;</a></span>max_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::max_element </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="max__element_8hpp.html">range/v3/algorithm/max_element.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gaeb9cc8e9a2bb6414d2c7df94a09be3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb9cc8e9a2bb6414d2c7df94a09be3e3">&#9670;&nbsp;</a></span>merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename O , typename C  = less, typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">merge_result&lt;I0, I1, O&gt; ranges::merge </td>
          <td>(</td>
          <td class="paramtype">I0&#160;</td>
          <td class="paramname"><em>begin0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S0&#160;</td>
          <td class="paramname"><em>end0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="merge_8hpp.html">range/v3/algorithm/merge.hpp</a>&gt;</code></p>

<p>function template <code>merge</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>sentinel_for&lt;S0, I0&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; mergeable&lt;I0, I1, O, C, P0, P1&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-algorithms.html#ga76bb637f6b8c0899daf6431f669ea385">ranges::merge()</a>.</p>

</div>
</div>
<a id="ga76bb637f6b8c0899daf6431f669ea385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76bb637f6b8c0899daf6431f669ea385">&#9670;&nbsp;</a></span>merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename Rng1 , typename O , typename C  = less, typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">merge_result&lt;borrowed_iterator_t&lt;Rng0&gt;, borrowed_iterator_t&lt;<a class="el" href="class_rng1.html">Rng1</a>&gt;, O&gt; ranges::merge </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="merge_8hpp.html">range/v3/algorithm/merge.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>range&lt;Rng0&gt; &amp;&amp; range&lt;Rng1&gt; &amp;&amp; mergeable&lt;iterator_t&lt;Rng0&gt;, iterator_t&lt;Rng1&gt;, O, C, P0, P1&gt;</code> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__group-algorithms.html#gaeb9cc8e9a2bb6414d2c7df94a09be3e3">ranges::merge()</a>.</p>

</div>
</div>
<a id="ga201c55750b7ffaf8f3bf707cb79f7b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga201c55750b7ffaf8f3bf707cb79f7b69">&#9670;&nbsp;</a></span>min() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr range_value_t&lt;Rng&gt; ranges::min </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="min_8hpp.html">range/v3/algorithm/min.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; indirectly_copyable_storable&lt;iterator_t&lt;Rng&gt;, range_value_t&lt;Rng&gt; *&gt;</code> </dd></dl>

</div>
</div>
<a id="gaebe356f1f4c0826477e74c34f54d9c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebe356f1f4c0826477e74c34f54d9c8f">&#9670;&nbsp;</a></span>min() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C  = less, typename P  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T ranges::min </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt; const &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="min_8hpp.html">range/v3/algorithm/min.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>copyable&lt;T&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga6f3fae929128282a29d51fa452f2fc16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f3fae929128282a29d51fa452f2fc16">&#9670;&nbsp;</a></span>min() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C  = less, typename P  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T const&amp; ranges::min </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="min_8hpp.html">range/v3/algorithm/min.hpp</a>&gt;</code></p>

<p>function template <code>min</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gacb04fb9206e52dcd5a8bbfa2084146b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb04fb9206e52dcd5a8bbfa2084146b7">&#9670;&nbsp;</a></span>min_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::min_element </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="min__element_8hpp.html">range/v3/algorithm/min_element.hpp</a>&gt;</code></p>

<p>function template <code>min_element</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga21e15bfbd4bbba21618c55c873486684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21e15bfbd4bbba21618c55c873486684">&#9670;&nbsp;</a></span>min_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::min_element </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="min__element_8hpp.html">range/v3/algorithm/min_element.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga88d3a1dad8f5b506eb9d437d82205609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88d3a1dad8f5b506eb9d437d82205609">&#9670;&nbsp;</a></span>minmax() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr minmax_result&lt;range_value_t&lt;Rng&gt; &gt; ranges::minmax </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="minmax_8hpp.html">range/v3/algorithm/minmax.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; indirectly_copyable_storable&lt;iterator_t&lt;Rng&gt;, range_value_t&lt;Rng&gt; *&gt;</code> </dd></dl>

</div>
</div>
<a id="gaffdee79083e3876c7562153203673fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffdee79083e3876c7562153203673fb8">&#9670;&nbsp;</a></span>minmax() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C  = less, typename P  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr minmax_result&lt;T&gt; ranges::minmax </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt; const &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="minmax_8hpp.html">range/v3/algorithm/minmax.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>copyable&lt;T&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga20cd213410245835bdafb2e6eb996895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20cd213410245835bdafb2e6eb996895">&#9670;&nbsp;</a></span>minmax() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C  = less, typename P  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr minmax_result&lt;T const &amp;&gt; ranges::minmax </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="minmax_8hpp.html">range/v3/algorithm/minmax.hpp</a>&gt;</code></p>

<p>function template <code>minmax</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gabdaf4d2ee6602188897c4bed53c717fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdaf4d2ee6602188897c4bed53c717fc">&#9670;&nbsp;</a></span>minmax_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">minmax_element_result&lt;I&gt; ranges::minmax_element </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="minmax__element_8hpp.html">range/v3/algorithm/minmax_element.hpp</a>&gt;</code></p>

<p>function template <code>minmax_element</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga043d5fb1cf4ae4823bfa6d9694dea74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga043d5fb1cf4ae4823bfa6d9694dea74a">&#9670;&nbsp;</a></span>minmax_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">minmax_element_result&lt;borrowed_iterator_t&lt;Rng&gt; &gt; ranges::minmax_element </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="minmax__element_8hpp.html">range/v3/algorithm/minmax_element.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gaed939edaa257e1915717af8a2cad2874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed939edaa257e1915717af8a2cad2874">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mismatch_result&lt;I1, I2&gt; ranges::mismatch </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mismatch_8hpp.html">range/v3/algorithm/mismatch.hpp</a>&gt;</code></p>

<p>function template <code>mismatch</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; input_iterator&lt;I2&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gaad99c5ed9f1a8ac6b7b28b6101ce0c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad99c5ed9f1a8ac6b7b28b6101ce0c55">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mismatch_result&lt;I1, I2&gt; ranges::mismatch </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mismatch_8hpp.html">range/v3/algorithm/mismatch.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; input_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga53d1762ffef58449321c655da78c52cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53d1762ffef58449321c655da78c52cc">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mismatch_result&lt;borrowed_iterator_t&lt;<a class="el" href="class_rng1.html">Rng1</a>&gt;, borrowed_iterator_t&lt;<a class="el" href="class_rng2.html">Rng2</a>&gt; &gt; ranges::mismatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mismatch_8hpp.html">range/v3/algorithm/mismatch.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng1&gt; &amp;&amp; input_range&lt;Rng2&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;iterator_t&lt;Rng1&gt;, P1&gt;, projected&lt;iterator_t&lt;Rng2&gt;, P2&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga7934e0a0e37148a7b0ba6ea1767c2471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7934e0a0e37148a7b0ba6ea1767c2471">&#9670;&nbsp;</a></span>move() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">move_result&lt;I, O&gt; ranges::move </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2move_8hpp.html">range/v3/algorithm/move.hpp</a>&gt;</code></p>

<p>function template <code>move</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_movable&lt;I, O&gt;</code> </dd></dl>

</div>
</div>
<a id="ga74247b371dbb7594cc424f0f13e4b614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74247b371dbb7594cc424f0f13e4b614">&#9670;&nbsp;</a></span>move() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">move_result&lt;borrowed_iterator_t&lt;Rng&gt;, O&gt; ranges::move </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2move_8hpp.html">range/v3/algorithm/move.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_movable&lt;iterator_t&lt;Rng&gt;, O&gt;</code> </dd></dl>

</div>
</div>
<a id="gae774997d392e48e40b1e9f03d0660aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae774997d392e48e40b1e9f03d0660aa0">&#9670;&nbsp;</a></span>move_backward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">move_backward_result&lt;I, O&gt; ranges::move_backward </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>end_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="move__backward_8hpp.html">range/v3/algorithm/move_backward.hpp</a>&gt;</code></p>

<p>function template <code>move_backward</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; bidirectional_iterator&lt;O&gt; &amp;&amp; indirectly_movable&lt;I, O&gt;</code> </dd></dl>

</div>
</div>
<a id="ga8084287106366f33e76614516ff00de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8084287106366f33e76614516ff00de3">&#9670;&nbsp;</a></span>move_backward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">move_backward_result&lt;borrowed_iterator_t&lt;Rng&gt;, O&gt; ranges::move_backward </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="move__backward_8hpp.html">range/v3/algorithm/move_backward.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_range&lt;Rng&gt; &amp;&amp; bidirectional_iterator&lt;O&gt; &amp;&amp; indirectly_movable&lt;iterator_t&lt;Rng&gt;, O&gt;</code> </dd></dl>

</div>
</div>
<a id="gabbad66b96d048b2dbc113f4d4d8871c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbad66b96d048b2dbc113f4d4d8871c7">&#9670;&nbsp;</a></span>next_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::next_permutation </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>end_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="permutation_8hpp.html">range/v3/algorithm/permutation.hpp</a>&gt;</code></p>

<p>function template <code>next_permutation</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</code> </dd></dl>

</div>
</div>
<a id="ga65344ec6be87cfbd56a501a6504213c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65344ec6be87cfbd56a501a6504213c6">&#9670;&nbsp;</a></span>next_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::next_permutation </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="permutation_8hpp.html">range/v3/algorithm/permutation.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-iterator.html#ga086fe1e8012d67f64dedab5fa37c525e">iter_swap</a>.</p>

</div>
</div>
<a id="gac9d57af7919545020540efa343e2c331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9d57af7919545020540efa343e2c331">&#9670;&nbsp;</a></span>none_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::none_of </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="none__of_8hpp.html">range/v3/algorithm/none_of.hpp</a>&gt;</code></p>

<p>function template <code>none_of</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga82de9da4afa96d2cd8d116f3ab6046ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82de9da4afa96d2cd8d116f3ab6046ce">&#9670;&nbsp;</a></span>none_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::none_of </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="none__of_8hpp.html">range/v3/algorithm/none_of.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga1bf32fdbad08e6e163dffef87374d8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bf32fdbad08e6e163dffef87374d8e5">&#9670;&nbsp;</a></span>nth_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::nth_element </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>nth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>end_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="nth__element_8hpp.html">range/v3/algorithm/nth_element.hpp</a>&gt;</code></p>

<p>function template <code>nth_element</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_iterator&lt;I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</code> </dd></dl>

</div>
</div>
<a id="ga493c30e7b6420ba5756207ef72e041e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga493c30e7b6420ba5756207ef72e041e2">&#9670;&nbsp;</a></span>nth_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::nth_element </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_t&lt; Rng &gt;&#160;</td>
          <td class="paramname"><em>nth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="nth__element_8hpp.html">range/v3/algorithm/nth_element.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</code> </dd></dl>

</div>
</div>
<a id="gaa363038c0a0b57f21b453f58d1266f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa363038c0a0b57f21b453f58d1266f4e">&#9670;&nbsp;</a></span>partial_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::partial_sort </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partial__sort_8hpp.html">range/v3/algorithm/partial_sort.hpp</a>&gt;</code></p>

<p>function template <code>partial_sort</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>sortable&lt;I, C, P&gt; &amp;&amp; random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-algorithms.html#ga2db73e0d2a523b1bfe4b7ce3f25c7dcc">ranges::partial_sort()</a>.</p>

</div>
</div>
<a id="ga2db73e0d2a523b1bfe4b7ce3f25c7dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2db73e0d2a523b1bfe4b7ce3f25c7dcc">&#9670;&nbsp;</a></span>partial_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::partial_sort </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_t&lt; Rng &gt;&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partial__sort_8hpp.html">range/v3/algorithm/partial_sort.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; &amp;&amp; random_access_range&lt;Rng&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-iterator.html#ga086fe1e8012d67f64dedab5fa37c525e">iter_swap</a>, and <a class="el" href="group__group-functional.html#ga251c7b8f81fd520e52412fc767a80a5e">ranges::ref</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__group-algorithms.html#gaa363038c0a0b57f21b453f58d1266f4e">ranges::partial_sort()</a>.</p>

</div>
</div>
<a id="gaa9cce103eb42a712a58c939d57a34d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9cce103eb42a712a58c939d57a34d18">&#9670;&nbsp;</a></span>partial_sort_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename SI , typename O , typename SO , typename C  = less, typename PI  = identity, typename PO  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">O ranges::partial_sort_copy </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SI&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SO&#160;</td>
          <td class="paramname"><em>out_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PI&#160;</td>
          <td class="paramname"><em>in_proj</em> = <code>PI{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PO&#160;</td>
          <td class="paramname"><em>out_proj</em> = <code>PO{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partial__sort__copy_8hpp.html">range/v3/algorithm/partial_sort_copy.hpp</a>&gt;</code></p>

<p>function template <code>partial_sort_copy</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;SI, I&gt; &amp;&amp; random_access_iterator&lt;O&gt; &amp;&amp; sentinel_for&lt;SO, O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt; &amp;&amp; sortable&lt;O, C, PO&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I, PI&gt;, projected&lt;O, PO&gt;&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-algorithms.html#gadc26b2da998f1c2610be46785d691965">ranges::partial_sort_copy()</a>.</p>

</div>
</div>
<a id="gadc26b2da998f1c2610be46785d691965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc26b2da998f1c2610be46785d691965">&#9670;&nbsp;</a></span>partial_sort_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InRng , typename OutRng , typename C  = less, typename PI  = identity, typename PO  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;OutRng&gt; ranges::partial_sort_copy </td>
          <td>(</td>
          <td class="paramtype">InRng &amp;&amp;&#160;</td>
          <td class="paramname"><em>in_rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutRng &amp;&amp;&#160;</td>
          <td class="paramname"><em>out_rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PI&#160;</td>
          <td class="paramname"><em>in_proj</em> = <code>PI{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PO&#160;</td>
          <td class="paramname"><em>out_proj</em> = <code>PO{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partial__sort__copy_8hpp.html">range/v3/algorithm/partial_sort_copy.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;InRng&gt; &amp;&amp; random_access_range&lt;OutRng&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;InRng&gt;, iterator_t&lt;OutRng&gt;&gt; &amp;&amp; sortable&lt;iterator_t&lt;OutRng&gt;, C, PO&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;InRng&gt;, PI&gt;, projected&lt;iterator_t&lt;OutRng&gt;, PO&gt;&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-algorithms.html#ga262acf8b1a6f9d0bfd35a20fcb474c51">ranges::make_heap()</a>, <a class="el" href="group__group-functional.html#ga251c7b8f81fd520e52412fc767a80a5e">ranges::ref</a>, and <a class="el" href="group__group-algorithms.html#gae3b2b50224f18da2d4c5601c388b86ac">ranges::sort_heap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__group-algorithms.html#gaa9cce103eb42a712a58c939d57a34d18">ranges::partial_sort_copy()</a>.</p>

</div>
</div>
<a id="ga97f1ddf8cf137833ab7e0c9f1d03b2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97f1ddf8cf137833ab7e0c9f1d03b2d8">&#9670;&nbsp;</a></span>partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::partition </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partition_8hpp.html">range/v3/algorithm/partition.hpp</a>&gt;</code></p>

<p>function template <code>partition</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>permutable&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga987745c576bda2edea769132ca28f7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987745c576bda2edea769132ca28f7f8">&#9670;&nbsp;</a></span>partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::partition </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partition_8hpp.html">range/v3/algorithm/partition.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga9ada17895d1ee5bd9e5630f8dcae37df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ada17895d1ee5bd9e5630f8dcae37df">&#9670;&nbsp;</a></span>partition_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O0 , typename O1 , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">partition_copy_result&lt;I, O0, O1&gt; ranges::partition_copy </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O0&#160;</td>
          <td class="paramname"><em>o0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O1&#160;</td>
          <td class="paramname"><em>o1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partition__copy_8hpp.html">range/v3/algorithm/partition_copy.hpp</a>&gt;</code></p>

<p>function template <code>partition_copy</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O0&gt; &amp;&amp; weakly_incrementable&lt;O1&gt; &amp;&amp; indirectly_copyable&lt;I, O0&gt; &amp;&amp; indirectly_copyable&lt;I, O1&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga4f0e361fe494bb4e89b6226633f9a873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f0e361fe494bb4e89b6226633f9a873">&#9670;&nbsp;</a></span>partition_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O0 , typename O1 , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">partition_copy_result&lt;borrowed_iterator_t&lt;Rng&gt;, O0, O1&gt; ranges::partition_copy </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O0&#160;</td>
          <td class="paramname"><em>o0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O1&#160;</td>
          <td class="paramname"><em>o1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partition__copy_8hpp.html">range/v3/algorithm/partition_copy.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O0&gt; &amp;&amp; weakly_incrementable&lt;O1&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O0&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O1&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga46862e538efe454cea0319c4eb4a0971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46862e538efe454cea0319c4eb4a0971">&#9670;&nbsp;</a></span>partition_point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::partition_point </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partition__point_8hpp.html">range/v3/algorithm/partition_point.hpp</a>&gt;</code></p>

<p>function template <code>partition_point</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt;</code> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__group-algorithms.html#ga660e7a35e981781951b4de7fff544802">ranges::lower_bound()</a>.</p>

</div>
</div>
<a id="gac459d68549e5035017526ea753324127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac459d68549e5035017526ea753324127">&#9670;&nbsp;</a></span>partition_point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::partition_point </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partition__point_8hpp.html">range/v3/algorithm/partition_point.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gad683654880ba140d1b7f4abdf27c8f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad683654880ba140d1b7f4abdf27c8f50">&#9670;&nbsp;</a></span>pop_heap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::pop_heap </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>

<p>function template <code>pop_heap</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</code> </dd></dl>

</div>
</div>
<a id="gacfaf935b1bf578fd762c9122f3a2d477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfaf935b1bf578fd762c9122f3a2d477">&#9670;&nbsp;</a></span>pop_heap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::pop_heap </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</code> </dd></dl>

</div>
</div>
<a id="ga35e4305e5a7028c2795088228483a4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35e4305e5a7028c2795088228483a4fa">&#9670;&nbsp;</a></span>prev_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::prev_permutation </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>end_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="permutation_8hpp.html">range/v3/algorithm/permutation.hpp</a>&gt;</code></p>

<p>function template <code>prev_permutation</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</code> </dd></dl>

</div>
</div>
<a id="gacec90d3d5c7083285553c6de395acc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacec90d3d5c7083285553c6de395acc92">&#9670;&nbsp;</a></span>prev_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ranges::prev_permutation </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="permutation_8hpp.html">range/v3/algorithm/permutation.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-iterator.html#ga086fe1e8012d67f64dedab5fa37c525e">iter_swap</a>.</p>

</div>
</div>
<a id="ga704ea334d99e4a5af0bf81988f771d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga704ea334d99e4a5af0bf81988f771d67">&#9670;&nbsp;</a></span>push_heap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::push_heap </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>

<p>function template <code>push_heap</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</code> </dd></dl>

</div>
</div>
<a id="gaeb3991e5dbdd90ba10a8143832d31333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb3991e5dbdd90ba10a8143832d31333">&#9670;&nbsp;</a></span>push_heap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::push_heap </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</code> </dd></dl>

</div>
</div>
<a id="gad89961c91281e7d6826e37c890cf34e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad89961c91281e7d6826e37c890cf34e4">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename T , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::remove </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2remove_8hpp.html">range/v3/algorithm/remove.hpp</a>&gt;</code></p>

<p>function template <code>remove</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>permutable&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, T const *&gt;</code> </dd></dl>

</div>
</div>
<a id="ga84ea278263269d9f6d0e62fc3188c340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84ea278263269d9f6d0e62fc3188c340">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename T , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::remove </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2remove_8hpp.html">range/v3/algorithm/remove.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, T const *&gt;</code> </dd></dl>

</div>
</div>
<a id="gae9be4f0ea2feb61677a0054563c08aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9be4f0ea2feb61677a0054563c08aba">&#9670;&nbsp;</a></span>remove_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O , typename T , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">remove_copy_result&lt;I, O&gt; ranges::remove_copy </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="remove__copy_8hpp.html">range/v3/algorithm/remove_copy.hpp</a>&gt;</code></p>

<p>function template <code>remove_copy</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, T const *&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</code> </dd></dl>

</div>
</div>
<a id="ga519f6c415fe173faf79c3759e0160d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga519f6c415fe173faf79c3759e0160d61">&#9670;&nbsp;</a></span>remove_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename T , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">remove_copy_result&lt;borrowed_iterator_t&lt;Rng&gt;, O&gt; ranges::remove_copy </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="remove__copy_8hpp.html">range/v3/algorithm/remove_copy.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, T const *&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</code> </dd></dl>

</div>
</div>
<a id="ga8bb4a3be82501194dfabe02e9ea6733a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bb4a3be82501194dfabe02e9ea6733a">&#9670;&nbsp;</a></span>remove_copy_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">remove_copy_if_result&lt;I, O&gt; ranges::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="remove__copy__if_8hpp.html">range/v3/algorithm/remove_copy_if.hpp</a>&gt;</code></p>

<p>function template <code>remove_copy_if</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</code> </dd></dl>

</div>
</div>
<a id="ga7565c31ed66deb9c075d04cfa1dec52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7565c31ed66deb9c075d04cfa1dec52e">&#9670;&nbsp;</a></span>remove_copy_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">remove_copy_if_result&lt;borrowed_iterator_t&lt;Rng&gt;, O&gt; ranges::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="remove__copy__if_8hpp.html">range/v3/algorithm/remove_copy_if.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</code> </dd></dl>

</div>
</div>
<a id="gafb87211288523ed6bfe2d12defe1b646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb87211288523ed6bfe2d12defe1b646">&#9670;&nbsp;</a></span>remove_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::remove_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2remove__if_8hpp.html">range/v3/algorithm/remove_if.hpp</a>&gt;</code></p>

<p>function template <code>remove_if</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>permutable&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga5439d9af75d1c2709f3bc4a8eff20f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5439d9af75d1c2709f3bc4a8eff20f21">&#9670;&nbsp;</a></span>remove_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::remove_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2remove__if_8hpp.html">range/v3/algorithm/remove_if.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gad9f0ab4f61c4cc77141474a8b072e3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9f0ab4f61c4cc77141474a8b072e3b0">&#9670;&nbsp;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename T1 , typename T2 , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::replace </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2replace_8hpp.html">range/v3/algorithm/replace.hpp</a>&gt;</code></p>

<p>function template <code>replace</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirectly_writable&lt;I, T2 const &amp;&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, T1 const *&gt;</code> </dd></dl>

</div>
</div>
<a id="gaf3a81c8dbd43c604acec346421deeef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3a81c8dbd43c604acec346421deeef6">&#9670;&nbsp;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename T1 , typename T2 , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::replace </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2replace_8hpp.html">range/v3/algorithm/replace.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirectly_writable&lt;iterator_t&lt;Rng&gt;, T2 const &amp;&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, T1 const *&gt;</code> </dd></dl>

</div>
</div>
<a id="gaa356096a9c9c1a7c98e2681b78fce078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa356096a9c9c1a7c98e2681b78fce078">&#9670;&nbsp;</a></span>replace_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O , typename T1 , typename T2 , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">replace_copy_result&lt;I, O&gt; ranges::replace_copy </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="replace__copy_8hpp.html">range/v3/algorithm/replace_copy.hpp</a>&gt;</code></p>

<p>function template <code>replace_copy</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; output_iterator&lt;O, T2 const &amp;&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, T1 const *&gt;</code> </dd></dl>

</div>
</div>
<a id="ga15cdc17bceab41545f4a53877f7479ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15cdc17bceab41545f4a53877f7479ef">&#9670;&nbsp;</a></span>replace_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename T1 , typename T2 , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">replace_copy_result&lt;borrowed_iterator_t&lt;Rng&gt;, O&gt; ranges::replace_copy </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="replace__copy_8hpp.html">range/v3/algorithm/replace_copy.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; output_iterator&lt;O, T2 const &amp;&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, T1 const *&gt;</code> </dd></dl>

</div>
</div>
<a id="ga8c28401b7718815f571b0de3871f762a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c28401b7718815f571b0de3871f762a">&#9670;&nbsp;</a></span>replace_copy_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O , typename C , typename T , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">replace_copy_if_result&lt;I, O&gt; ranges::replace_copy_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="replace__copy__if_8hpp.html">range/v3/algorithm/replace_copy_if.hpp</a>&gt;</code></p>

<p>function template <code>replace_copy_if</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; output_iterator&lt;O, T const &amp;&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</code> </dd></dl>

</div>
</div>
<a id="ga4d9b462cc8ce255c5a2e9ec19a05ec84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d9b462cc8ce255c5a2e9ec19a05ec84">&#9670;&nbsp;</a></span>replace_copy_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename C , typename T , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">replace_copy_if_result&lt;borrowed_iterator_t&lt;Rng&gt;, O&gt; ranges::replace_copy_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="replace__copy__if_8hpp.html">range/v3/algorithm/replace_copy_if.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; output_iterator&lt;O, T const &amp;&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</code> </dd></dl>

</div>
</div>
<a id="gaacafb6d5fad860c920547555d5365e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacafb6d5fad860c920547555d5365e16">&#9670;&nbsp;</a></span>replace_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C , typename T , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::replace_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2replace__if_8hpp.html">range/v3/algorithm/replace_if.hpp</a>&gt;</code></p>

<p>function template <code>replace_if</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt; &amp;&amp; indirectly_writable&lt;I, T const &amp;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga864292d2f285f303d3ca78f766bc70b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga864292d2f285f303d3ca78f766bc70b6">&#9670;&nbsp;</a></span>replace_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C , typename T , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::replace_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2replace__if_8hpp.html">range/v3/algorithm/replace_if.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; indirectly_writable&lt;iterator_t&lt;Rng&gt;, T const &amp;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga239c5b656b7d4eb1728146c27c79701a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga239c5b656b7d4eb1728146c27c79701a">&#9670;&nbsp;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::reverse </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>end_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2reverse_8hpp.html">range/v3/algorithm/reverse.hpp</a>&gt;</code></p>

<p>function template <code>reverse</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; permutable&lt;I&gt;</code> </dd></dl>

</div>
</div>
<a id="gab9376808c93a60e83f6e012405a780dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9376808c93a60e83f6e012405a780dc">&#9670;&nbsp;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename I  = iterator_t&lt;Rng&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::reverse </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2reverse_8hpp.html">range/v3/algorithm/reverse.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_range&lt;Rng&gt; &amp;&amp; permutable&lt;I&gt;</code> </dd></dl>

</div>
</div>
<a id="ga36294489bc4284839d44e5b994c8e668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36294489bc4284839d44e5b994c8e668">&#9670;&nbsp;</a></span>reverse_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_copy_result&lt;I, O&gt; ranges::reverse_copy </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>end_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reverse__copy_8hpp.html">range/v3/algorithm/reverse_copy.hpp</a>&gt;</code></p>

<p>function template <code>reverse_copy</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</code> </dd></dl>

</div>
</div>
<a id="gad516cf254a226899487ad08609f81128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad516cf254a226899487ad08609f81128">&#9670;&nbsp;</a></span>reverse_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_copy_result&lt;borrowed_iterator_t&lt;Rng&gt;, O&gt; ranges::reverse_copy </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reverse__copy_8hpp.html">range/v3/algorithm/reverse_copy.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</code> </dd></dl>

</div>
</div>
<a id="ga33a5ef3705f30edd28453a9999cd576d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33a5ef3705f30edd28453a9999cd576d">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structranges_1_1subrange.html">subrange</a>&lt;I&gt; ranges::rotate </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rotate_8hpp.html">range/v3/algorithm/rotate.hpp</a>&gt;</code></p>

<p>function template <code>rotate</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>permutable&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt;</code> </dd></dl>

</div>
</div>
<a id="gae12d6438e495d01fb95843e6b6f8c35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae12d6438e495d01fb95843e6b6f8c35b">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename I  = iterator_t&lt;Rng&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_subrange_t&lt;Rng&gt; ranges::rotate </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>middle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rotate_8hpp.html">range/v3/algorithm/rotate.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>range&lt;Rng&gt; &amp;&amp; permutable&lt;I&gt;</code> </dd></dl>

</div>
</div>
<a id="gab66377c07c8ec5bfe40e178161a05a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab66377c07c8ec5bfe40e178161a05a88">&#9670;&nbsp;</a></span>rotate_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rotate_copy_result&lt;I, O&gt; ranges::rotate_copy </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rotate__copy_8hpp.html">range/v3/algorithm/rotate_copy.hpp</a>&gt;</code></p>

<p>function template <code>rotate_copy</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</code> </dd></dl>

</div>
</div>
<a id="gac033357be8dd033636408498e7ee5f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac033357be8dd033636408498e7ee5f2f">&#9670;&nbsp;</a></span>rotate_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rotate_copy_result&lt;borrowed_iterator_t&lt;Rng&gt;, O&gt; ranges::rotate_copy </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_t&lt; Rng &gt;&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rotate__copy_8hpp.html">range/v3/algorithm/rotate_copy.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-utility.html#gaa77a9f8d78fe2ed9c14bde30e7523746">ranges::aux::copy</a>, and <a class="el" href="group__group-utility.html#ga20b5b25347e7f8173b2118fdb5ea5f58">ranges::aux::move</a>.</p>

</div>
</div>
<a id="gae8d67e6ed0aed443b194355578612321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8d67e6ed0aed443b194355578612321">&#9670;&nbsp;</a></span>sample() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O , typename Gen  = detail::default_random_engine &amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sample_result&lt;I, O&gt; ranges::sample </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iter_difference_t&lt; O &gt; const&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Gen &amp;&amp;&#160;</td>
          <td class="paramname"><em>gen</em> = <code>detail::get_random_engine()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2sample_8hpp.html">range/v3/algorithm/sample.hpp</a>&gt;</code></p>

<p>function template <code>sample</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt; &amp;&amp; uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp; (random_access_iterator&lt;O&gt; || forward_iterator&lt;I&gt; || sized_sentinel_for&lt;S, I&gt;)</code> </dd></dl>

</div>
</div>
<a id="gaaa000641779e549556cc32c94214f690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa000641779e549556cc32c94214f690">&#9670;&nbsp;</a></span>sample() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename ORng , typename Gen  = detail::default_random_engine &amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sample_result&lt;I, borrowed_iterator_t&lt;ORng&gt; &gt; ranges::sample </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ORng &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Gen &amp;&amp;&#160;</td>
          <td class="paramname"><em>gen</em> = <code>detail::get_random_engine()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2sample_8hpp.html">range/v3/algorithm/sample.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;iterator_t&lt;ORng&gt;&gt; &amp;&amp; indirectly_copyable&lt;I, iterator_t&lt;ORng&gt;&gt; &amp;&amp; uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp; (forward_range&lt;ORng&gt; || sized_range&lt;ORng&gt;) &amp;&amp; (random_access_iterator&lt;iterator_t&lt;ORng&gt;&gt; || forward_iterator&lt;I&gt; || sized_sentinel_for&lt;S, I&gt;)</code> </dd></dl>

</div>
</div>
<a id="ga31a99d76c57f2468f135e056dd4817a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31a99d76c57f2468f135e056dd4817a7">&#9670;&nbsp;</a></span>sample() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IRng , typename ORng , typename Gen  = detail::default_random_engine &amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sample_result&lt;borrowed_iterator_t&lt;IRng&gt;, borrowed_iterator_t&lt;ORng&gt; &gt; ranges::sample </td>
          <td>(</td>
          <td class="paramtype">IRng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ORng &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Gen &amp;&amp;&#160;</td>
          <td class="paramname"><em>gen</em> = <code>detail::get_random_engine()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2sample_8hpp.html">range/v3/algorithm/sample.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;IRng&gt; &amp;&amp; range&lt;ORng&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;IRng&gt;, iterator_t&lt;ORng&gt;&gt; &amp;&amp; uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp; (random_access_iterator&lt;iterator_t&lt;ORng&gt;&gt; || forward_range&lt;IRng&gt; || sized_range&lt;IRng&gt;) &amp;&amp; (forward_range&lt;ORng&gt; || sized_range&lt;ORng&gt;)</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-range.html#ga446b20253a26c93ef3004fcbfcbf3ec3">ranges::begin</a>, <a class="el" href="group__group-iterator.html#gaa5892e49da80688f61e93faf07c98746">ranges::distance</a>, <a class="el" href="group__group-range.html#ga80d92c391f5b5c0a50156af5f9c9d8c7">ranges::end</a>, and <a class="el" href="group__group-utility.html#ga20b5b25347e7f8173b2118fdb5ea5f58">ranges::aux::move</a>.</p>

</div>
</div>
<a id="ga8f3464d4bf77e969e86742fb67e40cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f3464d4bf77e969e86742fb67e40cce">&#9670;&nbsp;</a></span>sample() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename Gen  = detail::default_random_engine &amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sample_result&lt;borrowed_iterator_t&lt;Rng&gt;, O&gt; ranges::sample </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iter_difference_t&lt; O &gt; const&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Gen &amp;&amp;&#160;</td>
          <td class="paramname"><em>gen</em> = <code>detail::get_random_engine()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2sample_8hpp.html">range/v3/algorithm/sample.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp; uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp; (random_access_iterator&lt;O&gt; || forward_range&lt;Rng&gt; || sized_range&lt;Rng&gt;)</code> </dd></dl>

</div>
</div>
<a id="ga2619678aebd4a3f84fc5e82f0e7adc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2619678aebd4a3f84fc5e82f0e7adc9c">&#9670;&nbsp;</a></span>search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structranges_1_1subrange.html">subrange</a>&lt;I1&gt; ranges::search </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="search_8hpp.html">range/v3/algorithm/search.hpp</a>&gt;</code></p>

<p>function template <code>search</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; forward_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; indirectly_comparable&lt;I1, I2, C, P1, P2&gt;</code> </dd></dl>

</div>
</div>
<a id="ga084b0595139e0d6199f9caff6ae58ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga084b0595139e0d6199f9caff6ae58ba0">&#9670;&nbsp;</a></span>search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_subrange_t&lt;<a class="el" href="class_rng1.html">Rng1</a>&gt; ranges::search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="search_8hpp.html">range/v3/algorithm/search.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng1&gt; &amp;&amp; forward_range&lt;Rng2&gt; &amp;&amp; indirectly_comparable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, C, P1, P2&gt;</code> </dd></dl>

</div>
</div>
<a id="gaee041e8740d83af1fa6a316e3d17a67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee041e8740d83af1fa6a316e3d17a67e">&#9670;&nbsp;</a></span>search_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename V , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structranges_1_1subrange.html">subrange</a>&lt;I&gt; ranges::search_n </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iter_difference_t&lt; I &gt;&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="search__n_8hpp.html">range/v3/algorithm/search_n.hpp</a>&gt;</code></p>

<p>function template <code>search_n</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirectly_comparable&lt;I, V const *, C, P&gt;</code> </dd></dl>

</div>
</div>
<a id="ga2556ca4206528d72c5043e1c88ec48bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2556ca4206528d72c5043e1c88ec48bc">&#9670;&nbsp;</a></span>search_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_subrange_t&lt;Rng&gt; ranges::search_n </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iter_difference_t&lt; iterator_t&lt; Rng &gt;&gt;&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="search__n_8hpp.html">range/v3/algorithm/search_n.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; indirectly_comparable&lt;iterator_t&lt;Rng&gt;, V const *, C, P&gt;</code> </dd></dl>

</div>
</div>
<a id="ga8114322fbf39a5beb3c7d34baad0f2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8114322fbf39a5beb3c7d34baad0f2c3">&#9670;&nbsp;</a></span>set_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">set_difference_result&lt;I1, O&gt; ranges::set_difference </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>

<p>function template <code>set_difference</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>sentinel_for&lt;S1, I1&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; mergeable&lt;I1, I2, O, C, P1, P2&gt;</code> </dd></dl>

</div>
</div>
<a id="ga59edbf9d54ccf35065cf4accea2fb199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59edbf9d54ccf35065cf4accea2fb199">&#9670;&nbsp;</a></span>set_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">set_difference_result&lt;borrowed_iterator_t&lt;<a class="el" href="class_rng1.html">Rng1</a>&gt;, O&gt; ranges::set_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>range&lt;Rng1&gt; &amp;&amp; range&lt;Rng2&gt; &amp;&amp; mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, C, P1, P2&gt;</code> </dd></dl>

</div>
</div>
<a id="gaaf0526cb508732ba6f86873ce5a200d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf0526cb508732ba6f86873ce5a200d4">&#9670;&nbsp;</a></span>set_intersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">O ranges::set_intersection </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>

<p>function template <code>set_intersection</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>sentinel_for&lt;S1, I1&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; mergeable&lt;I1, I2, O, C, P1, P2&gt;</code> </dd></dl>

</div>
</div>
<a id="gaf5dc54963b11acb1941decff1d294a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5dc54963b11acb1941decff1d294a55">&#9670;&nbsp;</a></span>set_intersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">O ranges::set_intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>range&lt;Rng1&gt; &amp;&amp; range&lt;Rng2&gt; &amp;&amp; mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, C, P1, P2&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-range.html#ga446b20253a26c93ef3004fcbfcbf3ec3">ranges::begin</a>, <a class="el" href="group__group-range.html#ga80d92c391f5b5c0a50156af5f9c9d8c7">ranges::end</a>, and <a class="el" href="group__group-utility.html#ga20b5b25347e7f8173b2118fdb5ea5f58">ranges::aux::move</a>.</p>

</div>
</div>
<a id="gaedb5448383dd335b49a140b6d71237d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedb5448383dd335b49a140b6d71237d3">&#9670;&nbsp;</a></span>set_symmetric_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">set_symmetric_difference_result&lt;I1, I2, O&gt; ranges::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>

<p>function template <code>set_symmetric_difference</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>sentinel_for&lt;S1, I1&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; mergeable&lt;I1, I2, O, C, P1, P2&gt;</code> </dd></dl>

</div>
</div>
<a id="ga9453fef4931e8441d363cbca9784d038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9453fef4931e8441d363cbca9784d038">&#9670;&nbsp;</a></span>set_symmetric_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">set_symmetric_difference_result&lt;borrowed_iterator_t&lt;<a class="el" href="class_rng1.html">Rng1</a>&gt;, borrowed_iterator_t&lt;<a class="el" href="class_rng2.html">Rng2</a>&gt;, O&gt; ranges::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>range&lt;Rng1&gt; &amp;&amp; range&lt;Rng2&gt; &amp;&amp; mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, C, P1, P2&gt;</code> </dd></dl>

</div>
</div>
<a id="ga9a949af1cd40bea844eec95349af42bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a949af1cd40bea844eec95349af42bc">&#9670;&nbsp;</a></span>set_union() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">set_union_result&lt;I1, I2, O&gt; ranges::set_union </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>

<p>function template <code>set_union</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>sentinel_for&lt;S1, I1&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; mergeable&lt;I1, I2, O, C, P1, P2&gt;</code> </dd></dl>

</div>
</div>
<a id="gabcec48c80d2a0ec158e31112086fae4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcec48c80d2a0ec158e31112086fae4c">&#9670;&nbsp;</a></span>set_union() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">set_union_result&lt;borrowed_iterator_t&lt;<a class="el" href="class_rng1.html">Rng1</a>&gt;, borrowed_iterator_t&lt;<a class="el" href="class_rng2.html">Rng2</a>&gt;, O&gt; ranges::set_union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>range&lt;Rng1&gt; &amp;&amp; range&lt;Rng2&gt; &amp;&amp; mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, C, P1, P2&gt;</code> </dd></dl>

</div>
</div>
<a id="ga64a6b65cb4132a8a66c31fbe45ff3184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64a6b65cb4132a8a66c31fbe45ff3184">&#9670;&nbsp;</a></span>shuffle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename Gen  = detail::default_random_engine &amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::shuffle </td>
          <td>(</td>
          <td class="paramtype">I const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S const&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Gen &amp;&amp;&#160;</td>
          <td class="paramname"><em>gen</em> = <code>detail::get_random_engine()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2shuffle_8hpp.html">range/v3/algorithm/shuffle.hpp</a>&gt;</code></p>

<p>function template <code>shuffle</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; permutable&lt;I&gt; &amp;&amp; uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp; convertible_to&lt;invoke_result_t&lt;Gen &amp;&gt;, iter_difference_t&lt;I&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga46f7189cf5e33ed9a4cc65ef9e1bcf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46f7189cf5e33ed9a4cc65ef9e1bcf57">&#9670;&nbsp;</a></span>shuffle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename Gen  = detail::default_random_engine &amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::shuffle </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Gen &amp;&amp;&#160;</td>
          <td class="paramname"><em>rand</em> = <code>detail::get_random_engine()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2shuffle_8hpp.html">range/v3/algorithm/shuffle.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_range&lt;Rng&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp; uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp; convertible_to&lt;invoke_result_t&lt;Gen &amp;&gt;, iter_difference_t&lt;iterator_t&lt;Rng&gt;&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga008113a56544984350e5a0ab428acccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga008113a56544984350e5a0ab428acccd">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::sort </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>end_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2sort_8hpp.html">range/v3/algorithm/sort.hpp</a>&gt;</code></p>

<p>function template <code>sort</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>sortable&lt;I, C, P&gt; &amp;&amp; random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt;</code> </dd></dl>

</div>
</div>
<a id="gaaaebdad7bb17dd9fe0d23afe94eb9231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaebdad7bb17dd9fe0d23afe94eb9231">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::sort </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2sort_8hpp.html">range/v3/algorithm/sort.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; &amp;&amp; random_access_range&lt;Rng&gt;</code> </dd></dl>

<p class="reference">References <a class="el" href="group__group-utility.html#ga20b5b25347e7f8173b2118fdb5ea5f58">ranges::aux::move</a>, and <a class="el" href="group__group-iterator.html#gaf136ff254688f2c24f5c5f58df7ff56d">ranges::next</a>.</p>

</div>
</div>
<a id="gae3b2b50224f18da2d4c5601c388b86ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3b2b50224f18da2d4c5601c388b86ac">&#9670;&nbsp;</a></span>sort_heap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::sort_heap </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</code> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__group-algorithms.html#gadc26b2da998f1c2610be46785d691965">ranges::partial_sort_copy()</a>.</p>

</div>
</div>
<a id="ga0a5e8ae2a411dd9931c5af40827c53d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a5e8ae2a411dd9931c5af40827c53d3">&#9670;&nbsp;</a></span>sort_heap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::sort_heap </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>random_access_range&lt;Rng &amp;&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</code> </dd></dl>

</div>
</div>
<a id="ga56415c7caf1b400d608f758b08d9036e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56415c7caf1b400d608f758b08d9036e">&#9670;&nbsp;</a></span>stable_partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::stable_partition </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="stable__partition_8hpp.html">range/v3/algorithm/stable_partition.hpp</a>&gt;</code></p>

<p>function template <code>stable_partition</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt; &amp;&amp; permutable&lt;I&gt;</code> </dd></dl>

</div>
</div>
<a id="ga290c9e472e8224f67c0a24250c63536f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga290c9e472e8224f67c0a24250c63536f">&#9670;&nbsp;</a></span>stable_partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::stable_partition </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="stable__partition_8hpp.html">range/v3/algorithm/stable_partition.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga744aa2d7beb5a12115be0a7a1db6e86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga744aa2d7beb5a12115be0a7a1db6e86d">&#9670;&nbsp;</a></span>stable_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::stable_sort </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>end_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2stable__sort_8hpp.html">range/v3/algorithm/stable_sort.hpp</a>&gt;</code></p>

<p>function template <code>stable_sort</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>sortable&lt;I, C, P&gt; &amp;&amp; random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt;</code> </dd></dl>

</div>
</div>
<a id="gacbb4bbc0d34818b1601dec3812147d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbb4bbc0d34818b1601dec3812147d2e">&#9670;&nbsp;</a></span>stable_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::stable_sort </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2stable__sort_8hpp.html">range/v3/algorithm/stable_sort.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; &amp;&amp; random_access_range&lt;Rng&gt;</code> </dd></dl>

</div>
</div>
<a id="ga0aa76e38d88b172fc05bb4a556efa7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aa76e38d88b172fc05bb4a556efa7ed">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename Comp  = equal_to, typename Proj1  = identity, typename Proj2  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ranges::starts_with </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comp</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;range/v3/algorithm/starts_with.hpp&gt;</code></p>

<p>function template <code>starts_with</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; input_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; indirectly_comparable&lt;I1, I2, Comp, Proj1, Proj2&gt;</code> </dd></dl>

</div>
</div>
<a id="ga67981af4513f2c9962b5223e4f7115bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67981af4513f2c9962b5223e4f7115bf">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 , typename Comp  = equal_to, typename Proj1  = identity, typename Proj2  = identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ranges::starts_with </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comp</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;range/v3/algorithm/starts_with.hpp&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;R1&gt; &amp;&amp; input_range&lt;R2&gt; &amp;&amp; indirectly_comparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Comp, Proj1, Proj2&gt;</code> </dd></dl>

</div>
</div>
<a id="gaf9ae7d86273d4ae63fb1f7c7c21fa334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9ae7d86273d4ae63fb1f7c7c21fa334">&#9670;&nbsp;</a></span>swap_ranges() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">swap_ranges_result&lt;I1, I2&gt; ranges::swap_ranges </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="swap__ranges_8hpp.html">range/v3/algorithm/swap_ranges.hpp</a>&gt;</code></p>

<p>function template <code>swap_ranges</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; input_iterator&lt;I2&gt; &amp;&amp; indirectly_swappable&lt;I1, I2&gt;</code> </dd></dl>

</div>
</div>
<a id="ga8a583d3643b3f2057a280f54308f41e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a583d3643b3f2057a280f54308f41e9">&#9670;&nbsp;</a></span>swap_ranges() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename S2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">swap_ranges_result&lt;I1, I2&gt; ranges::swap_ranges </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="swap__ranges_8hpp.html">range/v3/algorithm/swap_ranges.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; input_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; indirectly_swappable&lt;I1, I2&gt;</code> </dd></dl>

</div>
</div>
<a id="gac7e4f36935f86807f07c653f0c10319c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7e4f36935f86807f07c653f0c10319c">&#9670;&nbsp;</a></span>swap_ranges() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename I2_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">swap_ranges_result&lt;iterator_t&lt;<a class="el" href="class_rng1.html">Rng1</a>&gt;, uncvref_t&lt;I2_&gt; &gt; ranges::swap_ranges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2_ &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="swap__ranges_8hpp.html">range/v3/algorithm/swap_ranges.hpp</a>&gt;</code></p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng1&gt; &amp;&amp; input_iterator&lt;uncvref_t&lt;I2_&gt;&gt; &amp;&amp; indirectly_swappable&lt;iterator_t&lt;Rng1&gt;, uncvref_t&lt;I2_&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gafa48d0e7d2e6042cee0d250875e513d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa48d0e7d2e6042cee0d250875e513d3">&#9670;&nbsp;</a></span>swap_ranges() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">swap_ranges_result&lt;borrowed_iterator_t&lt;<a class="el" href="class_rng1.html">Rng1</a>&gt;, borrowed_iterator_t&lt;<a class="el" href="class_rng2.html">Rng2</a>&gt; &gt; ranges::swap_ranges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng2.html">Rng2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="swap__ranges_8hpp.html">range/v3/algorithm/swap_ranges.hpp</a>&gt;</code></p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng1&gt; &amp;&amp; input_range&lt;Rng2&gt; &amp;&amp; indirectly_swappable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gac943a6f5b167780349d4444f08a32ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac943a6f5b167780349d4444f08a32ec9">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unary_transform_result&lt;I, O&gt; ranges::transform </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2transform_8hpp.html">range/v3/algorithm/transform.hpp</a>&gt;</code></p>

<p>function template <code>transform</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp; indirectly_writable&lt;O, indirect_result_t&lt;F &amp;, projected&lt;I, P&gt;&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga350c9661e3f88f03991b07c9e7ef37c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga350c9661e3f88f03991b07c9e7ef37c3">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I0 , typename S0 , typename I1 , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">binary_transform_result&lt;I0, I1, O&gt; ranges::transform </td>
          <td>(</td>
          <td class="paramtype">I0&#160;</td>
          <td class="paramname"><em>begin0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S0&#160;</td>
          <td class="paramname"><em>end0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2transform_8hpp.html">range/v3/algorithm/transform.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp; input_iterator&lt;I1&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp; indirectly_writable&lt; O, indirect_result_t&lt;F &amp;, projected&lt;I0, P0&gt;, projected&lt;I1, P1&gt;&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gad6b62572c5222d42401b35fdf9c0a473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6b62572c5222d42401b35fdf9c0a473">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">binary_transform_result&lt;I0, I1, O&gt; ranges::transform </td>
          <td>(</td>
          <td class="paramtype">I0&#160;</td>
          <td class="paramname"><em>begin0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S0&#160;</td>
          <td class="paramname"><em>end0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2transform_8hpp.html">range/v3/algorithm/transform.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp; input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp; indirectly_writable&lt; O, indirect_result_t&lt;F &amp;, projected&lt;I0, P0&gt;, projected&lt;I1, P1&gt;&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga498202023a2c6ad47bdb9a5f887c1396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga498202023a2c6ad47bdb9a5f887c1396">&#9670;&nbsp;</a></span>transform() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unary_transform_result&lt;borrowed_iterator_t&lt;Rng&gt;, O&gt; ranges::transform </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2transform_8hpp.html">range/v3/algorithm/transform.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp; indirectly_writable&lt;O, indirect_result_t&lt;F &amp;, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga529fe0621f3e1cf401a30caf1a28656d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga529fe0621f3e1cf401a30caf1a28656d">&#9670;&nbsp;</a></span>transform() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename I1Ref , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">binary_transform_result&lt;borrowed_iterator_t&lt;Rng0&gt;, uncvref_t&lt;I1Ref&gt;, O&gt; ranges::transform </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1Ref &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2transform_8hpp.html">range/v3/algorithm/transform.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng0&gt; &amp;&amp; input_iterator&lt;uncvref_t&lt;I1Ref&gt;&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp; indirectly_writable&lt; O, indirect_result_t&lt;F &amp;, projected&lt;iterator_t&lt;Rng0&gt;, P0&gt;, projected&lt;uncvref_t&lt;I1Ref&gt;, P1&gt;&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga9affa19cbbfedf9e33dd6786ea6977da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9affa19cbbfedf9e33dd6786ea6977da">&#9670;&nbsp;</a></span>transform() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename Rng1 , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">binary_transform_result&lt;borrowed_iterator_t&lt;Rng0&gt;, borrowed_iterator_t&lt;<a class="el" href="class_rng1.html">Rng1</a>&gt;, O&gt; ranges::transform </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rng1.html">Rng1</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2transform_8hpp.html">range/v3/algorithm/transform.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng0&gt; &amp;&amp; input_range&lt;Rng1&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp; indirectly_writable&lt; O, indirect_result_t&lt;F &amp;, projected&lt;iterator_t&lt;Rng0&gt;, P0&gt;, projected&lt;iterator_t&lt;Rng1&gt;, P1&gt;&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="gafd30ade930a7ad87d648a1a6d431524c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd30ade930a7ad87d648a1a6d431524c">&#9670;&nbsp;</a></span>unique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::unique </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2unique_8hpp.html">range/v3/algorithm/unique.hpp</a>&gt;</code></p>

<p>template function <code>unique</code> </p>
<p>range-based version of the <code>unique</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>forward_iterator</code> concept </dd>
<dd>
<code>S</code> is a model of the <code>sentinel_for</code> concept </dd>
<dd>
<code>C</code> is a model of the <code>relation</code> concept </dd>
<dd>
requires <code>sortable&lt;I, C, P&gt; &amp;&amp; sentinel_for&lt;S, I&gt;</code> </dd></dl>

</div>
</div>
<a id="ga8269b2eb3a23ae31e5b8cb357bcd68f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8269b2eb3a23ae31e5b8cb357bcd68f8">&#9670;&nbsp;</a></span>unique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::unique </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2unique_8hpp.html">range/v3/algorithm/unique.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; &amp;&amp; range&lt;Rng&gt;</code> </dd></dl>

</div>
</div>
<a id="ga3dd248f3be96356cb6dff51d14bc6e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dd248f3be96356cb6dff51d14bc6e65">&#9670;&nbsp;</a></span>unique_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unique_copy_result&lt;I, O&gt; ranges::unique_copy </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="unique__copy_8hpp.html">range/v3/algorithm/unique_copy.hpp</a>&gt;</code></p>

<p>template function unique_copy </p>
<p>range-based version of the <code>unique_copy</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>input_range</code> concept </dd>
<dd>
<code>O</code> is a model of the <code>weakly_incrementable</code> concept </dd>
<dd>
<code>C</code> is a model of the <code>relation</code> concept </dd>
<dd>
requires <code>input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;I, P&gt;&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt; &amp;&amp; (forward_iterator&lt;I&gt; || forward_iterator&lt;O&gt; || indirectly_copyable_storable&lt;I, O&gt;)</code> // </dd></dl>

</div>
</div>
<a id="gafd4603f5260f8c088a9baf919851ef0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd4603f5260f8c088a9baf919851ef0a">&#9670;&nbsp;</a></span>unique_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unique_copy_result&lt;borrowed_iterator_t&lt;Rng&gt;, O&gt; ranges::unique_copy </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="unique__copy_8hpp.html">range/v3/algorithm/unique_copy.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>input_range&lt;Rng&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp; (forward_iterator&lt;iterator_t&lt;Rng&gt;&gt; || forward_iterator&lt;O&gt; || indirectly_copyable_storable&lt;iterator_t&lt;Rng&gt;, O&gt;)</code> // </dd></dl>

</div>
</div>
<a id="gad76045249b0ecbf397dfd5f4c0e3d62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad76045249b0ecbf397dfd5f4c0e3d62e">&#9670;&nbsp;</a></span>unstable_remove_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::unstable_remove_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2unstable__remove__if_8hpp.html">range/v3/algorithm/unstable_remove_if.hpp</a>&gt;</code></p>

<p>unstable_remove have O(1) complexity for each element remove, unlike remove O(n) [for worst case]. Each erased element overwritten (moved in) with last one. unstable_remove_if does not preserve relative element order. </p>
<p>function template <code>unstable_remove_if</code> </p><dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_iterator&lt;I&gt; &amp;&amp; permutable&lt;I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga78222856ef024679c338b6ea320428d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78222856ef024679c338b6ea320428d5">&#9670;&nbsp;</a></span>unstable_remove_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::unstable_remove_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2unstable__remove__if_8hpp.html">range/v3/algorithm/unstable_remove_if.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>bidirectional_range&lt;Rng&gt; &amp;&amp; common_range&lt;Rng&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga204b1d4892ec45dda000e1221b4db7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga204b1d4892ec45dda000e1221b4db7f2">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I ranges::upper_bound </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="upper__bound_8hpp.html">range/v3/algorithm/upper_bound.hpp</a>&gt;</code></p>

<p>function template <code>upper_bound</code> </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;I, P&gt;&gt;</code> </dd></dl>

</div>
</div>
<a id="ga996b58ea852d27030d7502dc01573243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga996b58ea852d27030d7502dc01573243">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">borrowed_iterator_t&lt;Rng&gt; ranges::upper_bound </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="upper__bound_8hpp.html">range/v3/algorithm/upper_bound.hpp</a>&gt;</code></p>

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd>requires <code>forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</code> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
